## 概述

### 安装

``Linux``:inxx ``Mac``:inxx ``Windows``:inxx

web2py 提供用于 Windows 和 Mac OS X 的二进制包。二进制版本包含了 Python2.7 解释器,因此用户不需要预先安装。
源代码版本能在 Windows、Mac、Linux 和其它 Unix 系统上运行。源代码包版本假定计算机安装了 Python2.7或3.5（甚至更新）

web2py 不需要安装。启动时,针对特定的操作系统,解压下载的压缩(zip)文件,并运行相应的 ``web2py`` 文件。

在Unix和Linux(源代码版 source distribution)上运行:
``
python web2py.py
``:code

在OS X（可执行版 binary distribution）上运行:
``
open web2py.app
``:code

在Windows（可执行web2py版 binary web2py distribution）上运行:
``
web2py.exe
``:code

在Windows(源代码web2py版 source web2py distribution)上运行:
``
c:/Python27/python.exe web2py.py
``:code

------
请注意，如果在Windows上采用源码运行web2py，您必须从``http://sourceforge.net/projects/pywin32/``安装Mark Hammond的win32扩展。
------

web2py程序接受各种命令行选项,这将在后面讨论。

默认情况下,在启动时,web2py 会显示一个启动窗口,然后显示一个GUI部件,要求您选择一个一次性管理员密码、网络接口的IP地址和端口号,其中IP地址用于web服务器,端口号用于服务请求。默认情况下,web2py在127.0.0.1:8000(本地主机localhost上的8000端口)上运行它的Web服务器,但它也能够在任何可用的IP地址和端口上运行。你可以查询网络接口的IP地址,方法是在Windows下打开命令行、键入 ipconfig 或在 OS X 和Linux 下键入 ifconfig。从现在开始,我们假定 web2py 在 localhost(127.0.0.1:8000)上运行,使用 0.0.0.0:80 可以在任何网络接口上运行公开 web2py。

[[image @///image/en400.png center 306px]]

如果你不提供管理员密码,管理界面是不可用的。这是为了防止暴露管理界面而采取的安全措施。

管理界面**admin**仅能通过 localhost(本地主机)访问,除非你在后台使用带有mod_proxy 的 Apache 服务器上运行 web2py。如果**admin**检测到代理,会话 cookie 被设为安全,**admin** 登录不起作用,除非客户端和代理之间采用 HTTPS 通信这一安全措施。客户端和**admin**之间的所有通信必须始终是本地的或加密的;否则,攻击者将能发动中间（man-in-the middle）攻击或重放(replay)攻击,并在服务器端执行任意代码。

管理密码设置后,可以通过下面的网页访问web2py程序:
``
http://127.0.0.1:8000/
``:code

如果计算机没有默认的浏览器,打开一个 web 浏览器并输入 URL。

[[image @///image/en500.png center 480px]]

点击"administrative interface"将会进入admin管理界面的登录页面。

[[image @///image/en600.png center 480px]]

管理员密码是您在启动时你填写的那个密码。
请注意,管理员只有一个,因此也只有一个管理员密码,出于安全原因,web2py 每次启动时,开发人员都要选择一个新密码,除非<recycle>选项被指定,这有别于web2py应用中的身份验证机制。

管理员登录 web2py 之后,浏览器被定向到"site"页面。

[[image @///image/en700.png center 480px]]

该页面列出了全部已安装的 web2py 应用,并允许管理员管理它们。
web2py默认包含3个应用：
``admin``:inxx ``examples``:inxx ``welcome``:inxx ``scaffolding``:inxx
- 一个**admin**应用，就是你正在使用的。
- 一个**examples**应用，包含在线交互式文档和一个 web2py 官方网站的副本。
- 一个**welcome**应用，它是任何其它 web2py 应用的基本模板,也被称为基本构建应用(scaffolding application),也是当启动时欢迎用户的应用。

``appliances``:inxx
立即可用的 web2py 应用被称作 web2py ''appliances'' , 你可以在``appliances``:cite 下载许多免费提供的应用范例,鼓励 web2py 用户提交新的应用范例,无论是以开源还是闭源(编译和打包)的形式。

在**admin**应用的''site''页面，你可以进行如下操作：
- **导入** 通过填写页面右下角的表单,安装应用;给应用命名,选择包含封装应用的文件夹或应用所处位置的 URL,并点击 "submit"。
- **卸载** 通过点击相应按钮,卸载应用,卸载时会弹出确认页面。
- **创建** 通过填写一个名称,并点击 "create",即可创建一个新应用。
- **打包** 通过点击相应的按钮,打包应用发行。下载的应用是一个包括数据库的完整压缩(tar)文件,不用解压这个文件,使用**admin**安装后web2py会自动将它解压。
- **清理** 清理应用临时文件,例如会话、错误和缓存文件。
- **启用/禁用** 每个应用程序。当应用程序被禁用时，不能远程调用它，但本地主机不会禁用它。这意味着禁用的应用程序仍然可以在本地访问。通过在应用程序文件夹中创建一个名为“disabled”的文件，可以禁用应用程序。试图访问禁用应用程序的用户将收到“暂时停工维修”错误页面。您可以使用routes_onerror来定制错误页面。
- **编辑** 一个应用。

-----
在你用**admin**创建新应用时,它开始是作为带有一个"models/db.py"的"welcome"基本构建应用的克隆,"models/db.py"创建一个 SQLite 数据库,并连接到该数据库,实例化Auth、 Crud 和 Service,并配置它们。它还提供了一个"controller/default.py",为用户管理暴露了动作"index"、"download"和"user",为服务暴露了"call"。下面,我们假设这些文件已被删除,我们将从头开始创建应用。
-----

web2py还附带了一个**向导**,在本章后面介绍,基于网络上提供的布局、插件和模型的高层次描述,向导能为用户编写替代框架代码。

### 简单例子

#### 问好
``index``:inxx

一个例子,我们创建一个简单的 Web 应用,它向用户显示"Hello from MyApp",我们把这个应用称为“myapp”,还将增加一个统计用户访问相同页面次数的计数器

您可以通过在**admin**内 **site**页面右上角表单中键入应用的名称,你就可以创建一个新应用。

[[image @///image/en800.png center 447px]]

当你点击[create]按钮之后,新应用就会作为内置 welcome 的副本被创建。

[[image @///image/en900.png center 480px]]

要运行新应用,请访问:
``
http://127.0.0.1:8000/myapp
``:code

现在,你有一个 welcome 应用的副本了。

为了编辑应用,可以点击新创建应用的 ''edit'' 按钮。

**修改** 页面显示了应用中包含的所有文件。
每个 web2py 应用包括一些特定文件,其中大部分可归纳为以下六类:
- **models**: 描述数据表示。
- **controllers**: 描述应用逻辑和工作流程。
- **views**: 描述数据表达。
- **languages**: 描述如何将应用表达翻译成其它语言。
- **modules**: 属于应用的 Python 模块。
- **static files**: 静态图像,CSS ``css-w,css-o,css-school``:cite 文件,JavaScript``js-w,js-b``:cite文件等等。
- **plugins**: 用于设计协同工作的文件组。

遵循 MVC 设计模式,应用设计井然有序。''edit''页面中的每个部分对应于应用文件夹的一个子文件夹。

注意,节标题将切换其内容,静态文件的文件夹名称也是可折叠的。

-------
本节中列出的每个文件对应于子文件夹中的实体文件。通过 **admin** 界面对文件的任何操作(创建、编辑、删除),都可以使用您偏爱的编辑器直接从 shell 执行。
-------

该应用包含其它类型的文件(数据库、会话文件、错误文件等),但它们并没有在编辑页面中列出,因为它们不是由管理员创建或修改,而是由应用本身创建和修改。

控制器包含应用逻辑和工作流程,每个 URL 都被映射成控制器(actions)中某个函数的调用。有两个默认控制器:"appadmin.py"和"default.py", **appadmin**  提供数据库管理界面,目前我们还不需要它,"default.py"是你需要编辑的控制器,当 URL 中没有指定控制器时,默认调用它。编辑 "index" 函数如下:
``
def index():
    return "Hello from MyApp"
``:code

下面是在线编辑器的图示:

[[image @///image/en1000.png center 480px]]

保存并返回到''edit'' 页面。点击 index 链接访问新创建的页面。

当你访问URL时
``
http://127.0.0.1:8000/myapp/default/index
``:code

myapp应用中的默认控制器的index行为将被调用,它返回一个在浏览器中显示的字符串,如下图所示:

[[image @///image/en1100.png center 480px]]

现在,编辑 "index" 函数如下:
``
def index():
    return dict(message="Hello from MyApp")
``:code

从''edit'' 页面,编辑视图"default/index.html"(视图文件与 action 有关),并且用如下内容完全替换该文件的当前内容:
``
<html>
   <head></head>
   <body>
      <h1>{{=message}}</h1>
   </body>
</html>
``:code

现在 action 返回一个定义``message``的字典,当 action 返回一个字典时,web2py 会查找一个名称如下的视图:

``
[controller]/[function].[extension]
``:code

并执行它。这里``[extension]`` 是请求的扩展名,如果没有指定扩展名,默认为"html" ,这里我们也将这样假设,在这个假设下,视图是一个使用特殊标签{{ }}并嵌入 Python 代码的 HTML 文件,特别是,在本例中``{{=message}}`` 指示 web2py 用 action 返回的 ``message`` 值取代标签代码。注意,这里 ``message`` 不是一个 web2py 关键字,但被定义在 action 中。到目前为止我们没有使用任何 web2py 关键字。

如果 web2py 没有找到请求的视图, 它将使用通用视图“generic.html”。

-------
``Mac Mail``:inxx ``Google Maps``:inxx ``jsonp``:inxx
如果指定 "html" 以外的扩展名(例如"json" ),并且视图文件"[controller]/[function].json" 未被找到,web2py 将查找"generic.json"视图。web2py 带有generic.html、 generic.json、 generic.jsonp、 generic.xml、 generic.rss 、generic.ics (for Mac Mail Calendar)、generic.map (for embedding Google Maps)和generic.pdf (based on fpdf)。应用可以单独修改这些通用视图,并且可以很容易的添加其它视图。
-------

-------
通用视图是一种开发工具。在生产中每个 action 都应有自己的视图,实际上,默认时通用视图只能从 localhost 启用。
-------

-------
你也可以使用  ``response.view = 'default/something.html'``指定一个视图。
-------

在第 10 章中,你也可以看到有关这个主题的更多内容。

如果你回到"EDIT" 并点击 index,你将看到如下 HTML 页面:

[[image @///image/en1200.png center 480px]]

#### 调试工具栏
``toolbar``:inxx

出于调试目的，您可以插入

``
{{=response.toolbar()}}
``:code

到视图中,它会向你显示一些有用信息,包括请求、响应和会话对象,并列出所有数据库查询及其时间。

#### 计数
``session``:inxx
我们现在添加一个计数器到页面中,该计数器将统计相同访问者访问页面的次数。

web2py 将自动、透明的使用会话和 cookie 追踪访问者。对于新访问者, 它创建一个会话并分配唯一的"session_id" 。会话是一个存储服务器端变量的容器,唯一的 id 通过 cookie发送到浏览器,当访问者请求同一应用中的另一页面时,浏览器发回cookie,它被web2py回收并且相应的会话被恢复。

为了使用会话,修改默认控制器如下:
``
def index():
    if not session.counter:
        session.counter = 1
    else:
        session.counter += 1
    return dict(message="Hello from MyApp", counter=session.counter)
``:code

注意 ``counter`` 不是 web2py 关键字但 ``session``  是,我们要求 web2py 检查会话中是否有计数器变量,如果没有创建一个并将其设为 1,如果有计数器变量,我们要求 web2py 把计数器的值加 1。最后,我们把计数器的值传递给视图。

更紧凑更简洁的实现相同功能的代码如下:
``
def index():
    session.counter = (session.counter or 0) + 1
    return dict(message="Hello from MyApp", counter=session.counter)
``:code

现在修改视图,添加一行显示计数器值的代码:
``
<html>
   <head></head>
   <body>
      <h1>{{=message}}</h1>
      <h2>Number of visits: {{=counter}}</h2>
   </body>
</html>
``:code

当你再次访问 index 页面时,你应该得到以下 HTML 页面:

[[image @///image/en1300.png center 480px]]

计数器与每个访问者相关,访问者每次重载页面时计数器递增 1,不同访问者看到的计数器不同。


#### 说出我的名字
``form``:inxx ``request.vars``:inxx

现在创建两个页面(first 和 second),其中 first 页面创建一个表单,询问访问者的名字,并重定向到 second 页面,second 页面通过名字向访问者打招呼。

[[yUML diagram @///image/en1400.png center 200px]]

在默认控制器中写入相应 action(动作):
``
def first():
    return dict()

def second():
    return dict()
``:code

然后为 first action 创建一个视图"default/first.html",
并输入:
``
{{extend 'layout.html'}}
<h1>What is your name?</h1>
<form action="{{=URL('second')}}">
  <input name="visitor_name" />
  <input type="submit" />
</form>
``:code

最后,为 second action 创建一个视图 "default/second.html":
``
{{extend 'layout.html'}}
<h1>Hello {{=request.vars.visitor_name}}</h1>
``:code

``layout``:inxx
在这两个视图中,我们都扩展了 web2py 自带的基本视图 "layout.html",layout 视图保持两页面的外观和感觉一致,因为 layout 文件主要包含 HTML 代码,因此可以轻松地编辑和替换。

如果你现在访问 first 页面,输入你的名字:

[[image @///image/en1500.png center 480px]]

并提交表单,你将收到一个问候:

[[image @///image/en1600.png center 480px]]

#### 页面回传
``redirect``:inxx ``URL``:inxx ``postback``:inxx

我们前面使用的表单提交机制非常常见,但这并不是好的编程习惯。所有输入都应该进行验证，在上面的例子中,验证的负担会落在 second action 上,执行验证的 action 与生成表单的 action 不同,这往往造成代码冗余。

一个更好的表单提交模式是将表单提交给生成它们的action,在我们的例子中是"first", "first" action 应该接受变量、处理变量和将变量存储在服务器端,并将访问者重新定向到 "second"页面,该页面将回收变量,这种机制被称为''页面回传''(postback)。

[[yUML diagram @///image/en1700.png center 200px]]

修改默认控制器实现自提交:
``
def first():
    if request.vars.visitor_name:
        session.visitor_name = request.vars.visitor_name
        redirect(URL('second'))
    return dict()

def second():
    return dict()
``:code

然后,修改视图"default/first.html":
``
{{extend 'layout.html'}}
What is your name?
<form>
  <input name="visitor_name" />
  <input type="submit" />
</form>
``:code

并且 "default/second.html"视图需要从 ``session`` 而非 ``request.vars`` 恢复数据:
``
{{extend 'layout.html'}}
<h1>Hello {{=session.visitor_name or "anonymous"}}</h1>
``:code

从访问者的角度,自提交与先前的实现方法完全相同。我们还没有添加验证,但现在很清楚验证应该由 first action 执行。

这种方法比较好,因为访问者的名字留在 session 中,并且可以被应用程序中的所有 action 和 view 访问，而不需要显式地传递。

注意:在访问者名被设定之前,如果"second" action 被调用,它将显示"Hello anonymous",这是因为``session.visitor_name``返回为 ``None``。另外,我们可以在控制器中添加下面的代码(在 ``second`` 函数内):

``
if request.function != 'first' and not session.visitor_name:
    redirect(URL('first'))
``:code

这是在控制器上强制授权的一种''ad hoc''特定机制,更有效的方法参阅第9章。

``FORM``:inxx ``INPUT``:inxx ``requires``:inxx ``IS_NOT_EMPTY``:inxx ``accepts``:inxx

使用 web2py,我们可以更进一步，让web2py为我们生成包括验证在内的表单,web2py提供帮助对象(FORM、 INPUT、 TEXTAREA 和 SELECT/OPTION)。它们与等效的 HTML 标签同名,且它们可以用于在控制器或视图中构建表单。

例如,这里是改写 first action 的一种可能方式:
``
def first():
    form = FORM(INPUT(_name='visitor_name', requires=IS_NOT_EMPTY()),
                INPUT(_type='submit'))
    if form.process().accepted:
        session.visitor_name = form.vars.visitor_name
        redirect(URL('second'))
    return dict(form=form)
``:code

这里我们说的 FORM 标签包含两个 INPUT 标签,input 标签的属性由以下划线开头的命名参数指定。``requires`` 参数不是一个标签属性(因为它不以下划线开头),但为visitor_name的值设置了一个验证。

这里还有另一种更好的方式来创建相同的表单:

``
def first():
    form = SQLFORM.factory(Field('visitor_name',
                                 label='what is your name?',
                                 requires=IS_NOT_EMPTY()))
    if form.process().accepted:
        session.visitor_name = form.vars.visitor_name
        redirect(URL('second'))
    return dict(form=form)
``:code

通过在视图 "default/first.html" 中嵌入 ``form`` 对象,可以很容易的在 HTML 中将它序列化。
``
{{extend 'layout.html'}}
{{=form}}
``:code

``form.process()`` 方法使用了验证器并返回表单本身,如果表单已经被处理并通过验证,``form.accepted``变量将被设为 True。如果自提交表单通过验证,它将在会话中存储变量并像以前一样重定向。如果表单没有通过验证,错误消息会被插入到表单中,并以如下方式显示给用户:

[[image @///image/en1800.png center 480px]]

下一节,我们将展示如何从模型自动生成表单。

在我们的所有示例中，我们都使用会话将用户名从 first action 传递到second action。我们可以使用不同的机制，传递数据作为重定向URL的一部分:

``
def first():
    form = SQLFORM.factory(Field('visitor_name', requires=IS_NOT_EMPTY()))
    if form.process().accepted:
        name = form.vars.visitor_name
        redirect(URL('second', vars=dict(name=name)))
    return dict(form=form)

def second():
    name = request.vars.name or redirect(URL('first'))
    return dict(name=name)
``:code

然后,修改视图 "default/second.html":

``
{{extend 'layout.html'}}
<h1>Hello {{=name}}</h1>
``:code

请注意，通常使用URL将数据从一个 action 传递到另一个 action 不是一个好方式。这使得保护应用程序数据变得更加困难。在会话中存储数据更安全。

#### 国际化

您的代码可能包含硬编码的字符串，例如 "What is your name?"。 您应该能够在不编辑代码的情况下定制字符串，特别是在不同语言中插入这些字符串的翻译。这样，如果访问者的语言偏好设置为"意大利语"，web2py将使用意大利语翻译字符串。web2py的这个特性称为“国际化”，将在下一章详细介绍。

在这里我们只是看到，为了使用这个特性，您应该标记需要翻译的字符串。这是通过在代码中封装一个带引号的字符串来完成的，例如

``
"What is your name?"
``:code

用``T`` 操作符：

``
T("What is your name?")
``:code


您还可以为视图中硬编码的翻译字符串标记。例如

``
<h1>What is your name?</h1>
``:code

就变成了

``
<h1>{{=T("What is your name?")}}</h1>
``:code

对于代码中的每一个字符串(字段标签、flash消息等)，除了表和字段名之外，最好都这样做。

一旦确定并标记了字符串，web2py就会处理几乎所有其他事情。admin管理界面还提供了一个页面，您可以在其中用希望支持的语言翻译每个字符串。

-----------
web2py包括一个强大的多元化引擎，将在下一章中描述。它集成了国际化引擎和markmin渲染器。
-----------

### 一个图像博客
``upload``:inxx

在这里，作为另一个例子,在这里我们希望创建一个 Web 应用,它允许管理员发布图片并给它们命名,同时允许网站访问者查看命名的图片并提交评论(帖子posts)。

与之前一样,从  **admin** 中的 **site** 页面创建一个命名为 ``images``的新应用,并导航到 ''edit''页面:

[[image @///image/en1900.png center 480px]]

我们开始创建一个模型,即应用中持久数据的表示(上传的图像、它们的名字和评论)。首先,你需要创建/编辑模型文件,由于缺乏想象力,我们称之为 "db.py"。我们假设下面的代码将取代 "db.py"中任何现有的代码。模型和控制器必须具有 ``.py``扩展名,因为它们是Python 代码。如果没有提供扩展名,web2py 会自动添加,视图具有``.html``扩展名,因为它们主要包含 HTML 代码。

删除模型"menu.py"文件。

通过点击相应的 "edit" 按钮,可以编辑 "db.py" 文件:

[[image @///image/en2000.png center 480px]]

并输入以下代码:

``IS_EMAIL``:inxx ``IS_NOT_EMPTY``:inxx ``IS_IN_DB``:inxx
``
db = DAL("sqlite://storage.sqlite")

db.define_table('image',
                Field('title', unique=True),
                Field('file', 'upload'),
                format = '%(title)s')

db.define_table('post',
                Field('image_id', 'reference image'),
                Field('author'),
                Field('email'),
                Field('body', 'text'))

db.image.title.requires = IS_NOT_IN_DB(db, db.image.title)
db.post.image_id.requires = IS_IN_DB(db, db.image.id, '%(title)s')
db.post.author.requires = IS_NOT_EMPTY()
db.post.email.requires = IS_EMAIL()
db.post.body.requires = IS_NOT_EMPTY()

db.post.image_id.writable = db.post.image_id.readable = False
``:code

让我们来逐行分析一下

第 1 行定义一个表示数据库连接，称为 ``db`` 的全局变量。在本例中,它是一个到 SQLite数据库的连接,该数据库存储在"applications/images/databases/storage.sqlite"文件中,在使用 SQLite 情况下,如果数据库不存在则创建它,可以更改文件和全局变量 ``db``的名称,但给予它们相同的名称更便于记忆。

第 3-6 行定义一个"image"表。``define_table`` 是``db``对象的一个方法,第一个参数"image"是我们定义的表的名称,其它参数都是属于该表的字段,该表有一个"title"字段,一个"file"字段和一个"id"字段,并且"id"字段作为表的主键("id"没有显式声明,因为默认时所有表都有一个 id 字段)。"title"字段是一个字符串,字段"file"是"upload"类型。"upload"是一个特殊的字段类型,web2py 数据抽象层(DAL)用它来存储上传文件的名称。web2py 知道如何上传文件(如果文件大则用流媒体)、安全的重命名文件和存储文件。

当定义表时,web2py可能采取如下操作之一:
- 如果表不存在则创建它;
- 如果表存在但不符合定义,表将被相应的修改,如果字段有不同的类型,web2py会设法转换其内容;
- 如果表存在并且符合定义,web2py不执行任何操作。

这种行为被称为"migration"。在 web2py 中迁移(migration)是自动的,但通过传递 ``migrate=False`` 作为``define_table``的最后一个参数,可以禁用每个表的迁移。

第 6 行为表定义了一个格式字符串,它决定了如何将记录表示为一个字符串。注意, ``format`` 参数也可以是一个函数,该函数需要一个记录并返回一个字符串。例如:

``
format=lambda row: row.title
``:code

8-12 行定义另一个名为"post"的表。
"post"表包含"author"、"email"(我们打算存储文章作者的电子邮件地址)、"text"类型的"body"(我们打算用它来存储作者发布的评论)和引用类型的"image_id"字段通过"id"字段指向 ``db.image``。

在第 14 行,``db.image.title`` 表示"image"表的"title" 字段。属性``requires``允许您设置规定/限制,该规定/限制将被 web2py 表单强制设置,这里我们要求"title"是唯一的:

``IS_NOT_IN_DB(db, db.image.title)``:code

''注意这是可选的,鉴于``Field('title', unique=True)``它将被自动设置''。

表示这些限制的对象被称为验证器,多个验证器可以组合在一个列表中,并且根据出现的顺序执行验证。
``IS_NOT_IN_DB(a, b)`` 是一个特殊验证,它检查新纪录字段 ``b`` 的值是否已经不在``a``中。

第 15 行要求表"post" 的"image_id"字段在 ``db.image.id``中。就涉及的数据库而言,当定义表"post"时我们已经声明了这一点,现在我们明确地告诉模型,在表单处理层当有新评论发布时,该条件应当由 web2py 强制执行,这样无效值就不会从输入表单传递到数据库。
我们还要求用相应记录的"title" ,即``'%(title)s'``来代表"image_id"。

第 20 行表明"post" 表的字段 "image_id"不应显示在表单中,``writable=False`` ,甚至只读形式也不行,``readable=False``。

17-18 行中验证器的含义应该是显而易见的。

``format``:inxx
注意如下验证:
``
db.post.image_id.requires = IS_IN_DB(db, db.image.id, '%(title)s')
``:code

如果我们为引用的表指定格式,可以省略(并且是自动的)它:
``
db.define_table('image', ..., format='%(title)s')
``:code

这里该格式可以是字符串，也可以是接受记录并返回字符串的函数。

``appadmin``:inxx
一旦模型被定义,如果没有错误,web2py 创建一个应用管理界面来管理数据库,可以通过 ''edit'' 页面中的 "database administration" 链接来访问它,或者直接访问:
``
http://127.0.0.1:8000/images/appadmin
``:code

下面是 **appadmin** 界面的截图:

[[image @///image/en2100.png center 480px]]

此界面在控制器"appadmin.py"和相应的视图 "appadmin.html"中编码。从现在起,我们将把这一界面简单的称作 **appadmin**,它允许管理员插入新的数据库记录、编辑和删除现有记录、浏览表和进行数据库连接。

 **appadmin** 第一次被访问时,执行模型并创建表,web2py DAL 将 Python 代码翻译成针对选定数据库后台(本例中是 SQLite)的 SQL 语句,通过点击"models"下的 "sql.log" 链接,你可以从 ''edit'' 页面看到生成的 SQL,注意在表被创建之前链接是不存在的。

[[image @///image/en2200.png center 480px]]

如果你要编辑模型,并再次访问 **appadmin** ,web2py 会生成 SQL 来修改现有的表,生成的 SQL 被记录在“sql.log”中。

现在回到 **appadmin** ,并尝试插入一个新的图片记录:

[[image @///image/en2300.png center 480px]]

web2py 翻译 ``db.image.file`` 的"upload"字段为文件的上传表单,当表单被提交并且图像文件被上传时,将以安全的保留扩展名的方式重命名文件,用新文件名存储该文件到应用"uploads"文件夹中,新文件名将被保存在 ``db.image.file`` 字段中,该过程被设计来防止目录遍历攻击。

注意,每个字段类型由一个部件(''widget'')呈现,默认部件可能被重写。

当你在 **appadmin**中点击表名时,web2py 在当前表中执行选择所有记录,并由 DAL 查询确定:
``
db.image.id > 0
``:code

呈现结果如下。

[[image @///image/en2400.png center 480px]]

您可以通过编辑 DAL 查询并按 [Submit]来选择一组不同的记录集。

若要编辑或删除单个记录,可以点击记录的 id 号。

由于 ``IS_IN_DB`` 验证,引用字段 "image_id" 通过下拉菜单呈现,下拉列表将被存储为键(``db.image.id``),但由 ``db.image.title``表示,正如验证指定的一样。

验证器是功能强大的对象,它知道如何表示字段、过滤字段值、生成错误以及从字段中提取格式值。

下图显示了当您提交一个未通过验证的表单时会发生什么情况:

[[image @///image/en2500.png center 480px]]

由 **appadmin** 自动生成的相同表单,也可以通过 ``SQLFORM`` 帮助对象编程产生并嵌入用户应用中。这些表单都是 CSS 友好的且可被定制。

每个应用都有自己的 **appadmin**;因而, **appadmin**本身可以在不影响其它应用下被修改。

到目前为止,应用知道如何存储数据,并且我们已经看到如何通过**appadmin**访问数据库。仅限管理员访问**appadmin**,它的目的不是作为一个应用的生产web接口；因此下一部分逐步解说。具体来说,我们要创建:
- 一个"index"页面,按页面的标题排序,列出所有可用的图像以及图像详细信息页面的链接。
- 一个"show/[id]"页面,显示访问者请求的图像并允许访问者查看和发表评论。
- 一个"download/[name]"动作,下载上传的图片。

图示如下:

[[yUML diagram @///image/en2600.png center 480px]]

返回到''edit'' 页面并编辑 "default.py" 控制器,将其内容替换为以下内容:

``select``:inxx
``
def index():
    images = db().select(db.image.ALL, orderby=db.image.title)
    return dict(images=images)
``:code

此动作返回一个字典。字典中的条目的键被解释为变量,传递给与动作相关的视图。在开发时,如果没有视图,动作被"generic.html"视图呈现，每个 web2py 应用都提供该视图。

index 动作执行对表 image 中所有字段 (``db.image.ALL``) 的选择,按照 ``db.image.title``排序。选择的结果是一个``Rows`` 对象,其中包含选中的记录。将它赋值给一个局部变量,该局部变量叫做``images`` ,由动作返回给视图。 ``images`` 是迭代的,它的元素是选定的行,每行的列可以作为字典访问:
``images[0]['title']`` 或等价为 ``images[0].title``。

如果你没有写视图,字典将被 "views/generic.html"呈现并对 index 动作的调用如下:

[[image @///image/en2700.png center 480px]]

您还没有为该动作创建视图,因此 web2py 用普通表格形式呈现记录集。

继续为 index 动作建立一个视图。返回 admin,编辑 "default/index.html" 并将其内容替换为以下内容:
``
{{extend 'layout.html'}}
<h1>Current Images</h1>
<ul>
{{for image in images:}}
{{=LI(A(image.title, _href=URL("show", args=image.id)))}}
{{pass}}
</ul>
``:code

首先要注意的是,视图是有特殊标签{{...}}的纯HTML,嵌入{{...}}中的代码是纯Python 代码,需要注意一点:缩进是无关紧要的。代码块开始于以冒号(:)结束的行,并终止于以关键词 ``pass``结尾的行。在某些情况下,块的结尾从上下文看是很明显的,不需要使用 ``pass``。

5-7 行循环 image 的行,并为每行显示:
``
LI(A(image.title, _href=URL('show', args=image.id))
``:code

这是一个 ``<li>...</li>`` 标签,其中包含 ``<a href="...">...</a>`` 标签,该标签中包含 ``image.title``,超文本引用(href 属性)的值是:
``
URL('show', args=image.id)
``:code

即同一应用中的 URL 和控制器,该控制器作为当前请求调用函数 "show",传递一个参数给函数, ``args=image.id``。
``LI``, ``A``等是 web2py 帮助对象,它们映射到相应的 HTML 标签,它们的未命名参数被解释为需要序列化的对象并被插入标签内的 HTML,以下划线(例如 ``_href``)开始的命名参数被解释为不带下划线的标记属性。例如, ``_href`` 是 ``href`` 属性, ``_class`` 是 ``class`` 属性等。

例如:
``
{{=LI(A('something', _href=URL('show', args=123))}}
``:code

被呈现为:
``
<li><a href="/images/default/show/123">something</a></li>
``:code

一些帮助对象(``INPUT``, ``TEXTAREA``, ``OPTION`` 和 ``SELECT`` )也支持一些特殊的不以下划线开始的命名属性(``value``和  ``requires``)。它们对于构建定制表单非常重要，稍后将对此进行讨论。

返回 ''edit'' 页面,它现在表明"default.py exposes(暴露) index",通过点击"index",你可以访问新创建的页面:
``
http://127.0.0.1:8000/images/default/index
``:code

这看起来像:

[[image @///image/en2800.png center 480px]]

如果您点击图像名称链接，您将被定向到:
``
http://127.0.0.1:8000/images/default/show/1
``:code

这将导致错误,因为你还没有在控制器"default.py"中创建名为"show"的动作。

让我们编辑 "default.py" 控制器,并将其内容替换如下:

``SQLFORM``:inxx ``accepts``:inxx ``response.flash``:inxx ``request.args``:inxx
``response.download``:inxx
``
def index():
    images = db().select(db.image.ALL, orderby=db.image.title)
    return dict(images=images)

def show():
    image = db.image(request.args(0, cast=int)) or redirect(URL('index'))
    db.post.image_id.default = image.id
    form = SQLFORM(db.post)
    if form.process().accepted:
        response.flash = 'your comment is posted'
    comments = db(db.post.image_id == image.id).select(orderby=db.post.id)
    return dict(image=image, comments=comments, form=form)

def download():
    return response.download(request, db)
``:code

控制器包含两个动作: "show" 和 "download"。
"show"动作用从请求 args 中解析得到的 ``id`` ,选择图片和与其相关的所有评论,之后 "show" 将一切传递给视图 "default/show.html"。

引用图片 id:
``
URL('show', args=image.id)
``:code

在 "default/index.html"中,可以作为:"show"动作中的

``request.args(0, cast=int)``

被访问。``cast=int`` 参数是可选的，但非常重要。它试图将在PATH_INFO中传递的字符串值转换为int。如果失败，它将引发一个适当的异常，而不是引发一个票据。如果强制转换失败，还可以重定向:

``request.args(0, cast=int, otherwise=URL('error'))``

此外 ``db.image(...)`` 是一个快捷方式

``
db(db.image.id == ...).select().first()
``:code

"download" 动作需要 ``request.args(0)``中的文件名,建立一个路径到文件应该存在的位置,并把它发送回客户端。如果文件过大,它流式传输该文件,而不产生任何内存开销。

注意以下语句:
- 第 7 行设置引用字段的值，因为``db.post`` 不是输入表单的一部分而是表模型对象。
- 第 8 行为表 ``db.post`` 创建一个插入表单 SQLFORM。
- 第 9 行在当前会话(会话用来防止重复提交,强制执行导航)中处理提交的表单(提交的表单变量在 ``request.vars``中)。如果提交的表单变量经过验证,在表 ``db.post`` 中插入新评论;否则,表单被修改为包括错误消息(例如,如果作者的电子邮件地址无效),这一切都是在第 9 行中完成的!
- 第 10 行只在表单被接受才会被执行,记录被插入到数据库表中。 ``response.flash`` 是一个 web2py 变量,它被显示在视图中并被用来通知访问者发生了什么事情。
- 第 11 行选择所有引用当前图片的评论，``.select(orderby=db.post.id)`` 以字段id为条件排序评论。

-------
在基本构建应用的 "default.py" 控制器中,已经定义了 "download" 动作。
-------

"download"动作不返回字典,因此它不需要视图。但是,"show"动作应该有视图,因此返回 **admin** 并创建一个新的视图叫做 "default/show.html"。

编辑这个新文件并将其内容替换为以下内容:
``
{{extend 'layout.html'}}
<h1>Image: {{=image.title}}</h1>
<div style="text-align:center">
<img width="200px"
     src="{{=URL('download', args=image.file)}}" />
</div>
{{if len(comments):}}
  <h2>Comments</h2><br /><p>
  {{for post in comments:}}
    <p>{{=post.author}} says <i>{{=post.body}}</i></p>
  {{pass}}</p>
{{else:}}
  <h2>No comments posted yet</h2>
{{pass}}
<h2>Post a comment</h2>
{{=form}}
``:code

该视图通过调用 ``<img ... />`` 标签内的"download"动作显示 **image.file** 。
如果有评论,对它们循环,并显示每一个。

以下是显示给访问者的效果。

[[image @///image/en2900.png center 480px]]

当访问者通过此页提交评论,评论将被存储在数据库中并附加在页面底部。

#### 添加认证

web2py 基于角色的访问控制 API 是相当复杂的,但是现在我们会限制自己,限制通过身份验证的用户访问 show 动作,在第 9 章将进行更详细的讨论。

为了限制通过身份验证的用户访问,我们需要完成三个步骤。在一个模型中,例如 "db.py",我们需要添加:
``
from gluon.tools import Auth
auth = Auth(db)
auth.define_tables(username=True)
``:code

在我们的控制器中,我们需要添加一个动作:
``
def user():
    return dict(form=auth())
``:code

这足以启用登录、注册、注销等页面。默认布局还会在右上角显示相应页面的选项。

[[image @///image/en3000.png center 300px]]

现在我们可以修饰我们想要限制的函数,例如:
``
@auth.requires_login()
def show():
    ...
``:code

任何企图访问的尝试
``
http://127.0.0.1:8000/images/default/show/[image_id]
``:code

都需要登录。如果用户没有登录,用户将被重定向到
``
http://127.0.0.1:8000/images/default/user/login
``:code

[[image @///image/en3100.png center 480px]]

 ``user`` 函数还包括下列actions动作:
``
http://127.0.0.1:8000/images/default/user/logout
http://127.0.0.1:8000/images/default/user/register
http://127.0.0.1:8000/images/default/user/profile
http://127.0.0.1:8000/images/default/user/change_password
http://127.0.0.1:8000/images/default/user/request_reset_password
http://127.0.0.1:8000/images/default/user/retrieve_username
http://127.0.0.1:8000/images/default/user/retrieve_password
http://127.0.0.1:8000/images/default/user/verify_email
http://127.0.0.1:8000/images/default/user/impersonate
http://127.0.0.1:8000/images/default/user/not_authorized
``:code

现在,以便能够登录并阅读或发表评论,第一次登录的用户需要注册。

-------
 ``auth`` 对象和 ``user`` 函数都已经定义在基本构建应用中,``auth`` 对象高度可定制并且可以处理电子邮件验证,注册审批,验证码和其他登录方法。
-------

#### 添加网格(grids)

我们可以使用``SQLFORM.grid``和 ``SQLFORM.smartgrid`` 小工具进一步改善我们的应用,创建一个管理界面:

``
@auth.requires_membership('manager')
def manage():
    grid = SQLFORM.smartgrid(db.image, linked_tables=['post'])
    return dict(grid=grid)
``:code

带有相关的"views/default/manage.html"

``
{{extend 'layout.html'}}
<h2>Management Interface</h2>
{{=grid}}
``

使用 appadmin 创建组 "manager" 并使一些用户成为该组的成员,他们将能够访问

``
http://127.0.0.1:8000/images/default/manage
``

和浏览、搜索:

[[image @///image/en3200.png center 480px]]

创建、更新和删除图像以及他们的评论:

[[image @///image/en3300.png center 480px]]

#### 配置布局

您可以通过编辑 "views/layout.html" 来配置默认布局,也可以配置它而无需编辑HTML。实际上, "static/css/web2py.css" 样式表在第 5 章中有详细描述。您可以改变颜色、列、大小、边界和背景而无需编辑 HTML,如果您要编辑菜单、标题或副标题,可以在任何模型文件中操作,基本构建应用能在文件 "models/menu.py"中设置这些参数的默认值:

``
response.title = request.application
response.subtitle = 'customize me!'
response.meta.author = 'you'
response.meta.description = 'describe your app'
response.meta.keywords = 'bla bla bla'
response.menu = [ [ 'Index', False, URL('index') ] ]
``:code

### 一个简单的维基wiki
``wiki``:inxx ``RSS``:inxx ``Ajax``:inxx ``XMLRPC``:inxx

在本节中,我们仅使用最基本的API（而不是在下一节中演示web2py内置wiki功能）从头构建一个简单的wiki。访问者将能够创建页面,搜索页面(按照标题)并编辑页面,还能发表评论(与之前的应用完全相似),还可以上传文件(作为页面的附件)并从页面链接。作为惯例,我们的wiki 语法采用 Markmin 语法,还将使用 Ajax 实现一个搜索页面,该页面的 RSS 订阅,以及一个通过 XML-RPC``xmlrpc``:cite 搜索该页面。下图列出了我们需要实现的动作以及我们打算在其中构建的链接。

[[yUML diagram @///image/en3400.png center 200px]]

开始创建一个新的基本构建应用,命名为t "mywiki"。

该模型必须包含三个表:page(页面),comment(评论)和 document(文档),评论和文档都引用页面,是因为它们属于页面,文档包含 upload 类型的file字段,正如前面的images应用一样。

以下是完整的模型:
``
db = DAL('sqlite://storage.sqlite')

from gluon.tools import *
auth = Auth(db)
auth.define_tables()
crud = Crud(db)

db.define_table('page',
                Field('title'),
                Field('body', 'text'),
                Field('created_on', 'datetime', default=request.now),
                Field('created_by', 'reference auth_user', default=auth.user_id),
                format='%(title)s')

db.define_table('post',
                Field('page_id', 'reference page'),
                Field('body', 'text'),
                Field('created_on', 'datetime', default=request.now),
                Field('created_by', 'reference auth_user', default=auth.user_id))

db.define_table('document',
                Field('page_id', 'reference page'),
                Field('name'),
                Field('file', 'upload'),
                Field('created_on', 'datetime', default=request.now),
                Field('created_by', 'reference auth_user', default=auth.user_id),
                format='%(name)s')

db.page.title.requires = IS_NOT_IN_DB(db, 'page.title')
db.page.body.requires = IS_NOT_EMPTY()
db.page.created_by.readable = db.page.created_by.writable = False
db.page.created_on.readable = db.page.created_on.writable = False

db.post.body.requires = IS_NOT_EMPTY()
db.post.page_id.readable = db.post.page_id.writable = False
db.post.created_by.readable = db.post.created_by.writable = False
db.post.created_on.readable = db.post.created_on.writable = False

db.document.name.requires = IS_NOT_IN_DB(db, 'document.name')
db.document.page_id.readable = db.document.page_id.writable = False
db.document.created_by.readable = db.document.created_by.writable = False
db.document.created_on.readable = db.document.created_on.writable = False
``:code

编辑控制器 "default.py" 并创建以下动作:
- index: 列出所有的 wiki 页面
- create: 添加一个新的 wiki 页面
- show: 显示一个 wiki 页面以及它的评论,并追加新评论
- edit: 编辑一个现有页面
- documents: 管理附加到一个页面的文件
- download: 下载文件(如在 images 例子中)
- search: 显示一个搜索框并且通过 Ajax 回调,在访问者输入的同时返回所有匹配的标题
- callback: Ajax 回调函数。它返回在访问者输入时被嵌入搜索页面的 HTML。

这里是 "default.py" 控制器:
``
def index():
    """ this controller returns a dictionary rendered by the view
        it lists all wiki pages
    >>> index().has_key('pages')
    True
    """
    pages = db().select(db.page.id, db.page.title, orderby=db.page.title)
    return dict(pages=pages)

@auth.requires_login()
def create():
    """creates a new empty wiki page"""
    form = SQLFORM(db.page).process(next=URL('index'))
    return dict(form=form)

def show():
    """shows a wiki page"""
    this_page = db.page(request.args(0, cast=int)) or redirect(URL('index'))
    db.post.page_id.default = this_page.id
    form = SQLFORM(db.post).process() if auth.user else None
    pagecomments = db(db.post.page_id == this_page.id).select(orderby=db.post.id)
    return dict(page=this_page, comments=pagecomments, form=form)

@auth.requires_login()
def edit():
    """edit an existing wiki page"""
    this_page = db.page(request.args(0, cast=int)) or redirect(URL('index'))
    form = SQLFORM(db.page, this_page).process(
        next = URL('show', args=request.args))
    return dict(form=form)

@auth.requires_login()
def documents():
    """browser, edit all documents attached to a certain page"""
    page = db.page(request.args(0, cast=int)) or redirect(URL('index'))
    db.document.page_id.default = page.id
    grid = SQLFORM.grid(db.document.page_id == page.id, args=[page.id])
    return dict(page=page, grid=grid)

def user():
    return dict(form=auth())

def download():
    """allows downloading of documents"""
    return response.download(request, db)

def search():
    """an ajax wiki search page"""
    return dict(form=FORM(INPUT(_id='keyword',
                                _name='keyword',
                                _onkeyup="ajax('callback', ['keyword'], 'target');")),
                target_div=DIV(_id='target'))

def callback():
    """an ajax callback that returns a <ul> of links to wiki pages"""
    query = db.page.title.contains(request.vars.keyword)
    pages = db(query).select(orderby=db.page.title)
    links = [A(p.title, _href=URL('show', args=p.id)) for p in pages]
    return UL(*links)
``:code


第 2-6 行为 index 动作提供了一个评论,评论中的 4-5 行由 python 解释成测试代码(doctest),通过管理界面可以运行测试,在本例中,测试验证 index 动作运行没有错误。

第 18、27 和 35 行尝试用``request.args(0)``中的 id 获取一个 page 记录。


第 13、20 行为新页面和新评论定义和处理创建表单。

第 28 行定义和处理一个 wiki 页面的更新表单。

第 37 行创建一个 ``grid`` 对象来浏览、添加和更新链接到页面的评论。

第 51 行发生了一些奇妙的事情,INPUT 标签 "keyword" 的 ``onkeyup`` 属性被设定,每次访问者放开一个按键, ``onkeyup`` 属性中的 JavaScript 代码在客户端被执行。下面是 JavaScript 代码:
``
ajax('callback', ['keyword'], 'target');
``:code
``ajax`` 是一个在文件 "web2py.js" 中定义的 JavaScript 函数,默认的 "layout.html"包含该文件,它有三个参数:动作的 URL,执行同步回调;列表中变量的 ID,被发送到回调(["keyword"])和响应要插入的 ID("target")。

当您在搜索框中键入内容,并放开按键,客户端调用服务器并发送'keyword'字段的内容,而且当服务器响应时,响应被作为'target' 标签的内部 HTML 嵌入到页面中。

'target' 标签是一个 DIV 被定义在第 52 行中,也可以在视图中定义它。

下面是视图 "default/create.html"的代码:
``
{{extend 'layout.html'}}
<h1>Create new wiki page</h1>
{{=form}}
``:code

假设您已注册并登录，如果您访问 **create** 页面，您将看到以下内容:

[[image @///image/en3500.png center 480px]]

下面是视图 "default/index.html"的代码:
``
{{extend 'layout.html'}}
<h1>Available wiki pages</h1>
[ {{=A('search', _href=URL('search'))}} ]<br />
<ul>{{for page in pages:}}
     {{=LI(A(page.title, _href=URL('show', args=page.id)))}}
{{pass}}</ul>
[ {{=A('create page', _href=URL('create'))}} ]
``:code

它将生成如下页面:

[[image @///image/en3600.png center 480px]]

下面是视图"default/show.html"的代码:

``markdown``:inxx ``MARKMIN``:inxx
``
{{extend 'layout.html'}}
<h1>{{=page.title}}</h1>
[ {{=A('edit', _href=URL('edit', args=request.args))}} ]<br />
{{=MARKMIN(page.body)}}
<h2>Comments</h2>
{{for post in comments:}}
  <p>{{=db.auth_user[post.created_by].first_name}} on {{=post.created_on}}
     says <i>{{=post.body}}</i></p>
{{pass}}
<h2>Post a comment</h2>
{{=form}}
``:code

如果你想使用 markdown 语法取代 markmin 语法:

``
from gluon.contrib.markdown import WIKI as MARKDOWN
``:code

使用 WIKI 取代 MARKMIN 帮助对象。
或者,您可以选择原始的 HTML 取代 markmin 句法。在本例中,您将取代:
``
{{=MARKMIN(page.body)}}
``:code

with:
``
{{=XML(page.body)}}
``:code

``sanitize``:inxx
(这样 XML 没有得到转义,正如 web2py 出于安全考虑通常会这样做)。

更好的做法如下:
``
{{=XML(page.body, sanitize=True)}}
``:code

通过设定 ``sanitize=True``,告诉 web2py 转义不安全的 XML 标签例如 "<script>",这样防止 XSS 漏洞。

现在如果从 index 页面,点击页面标题,可以看到你创建的页面:

[[image @///image/en3700.png center 480px]]

下面是视图 "default/edit.html"的代码:
``
{{extend 'layout.html'}}
<h1>Edit wiki page</h1>
[ {{=A('show', _href=URL('show', args=request.args))}}
| {{=A('documents', _href=URL('documents', args=request.args))}} ]<br />
{{=form}}
``:code

它生成的页面看起来与create页面几乎相同。

下面是视图 "default/documents.html"的代码:
``
{{extend 'layout.html'}}
<h1>Documents for page: {{=page.title}}</h1>
[ {{=A('show', _href=URL('show', args=request.args))}} ]<br />
<h2>Documents</h2>
{{=grid}}
``:code

如果从 "show" 页面点击文件,现在可以管理附加到该页面的文件。

[[image @///image/en3800.png center 480px]]

最后是视图"default/search.html"的代码:
``
{{extend 'layout.html'}}
<h1>Search wiki pages</h1>
[ {{=A('listall', _href=URL('index'))}}]<br />
{{=form}}<br />{{=target_div}}
``:code

生成如下 Ajax 搜索表单:

[[image @///image/en3900.png center 480px]]

您还可以尝试直接调用 callback 动作,例如通过访问如下 URL:
``
http://127.0.0.1:8000/mywiki/default/callback?keyword=main
``:code

如果您看页面源代码,您会看到 callback 返回的 HTML:
``
<ul><li><a href="/mywiki/default/show/4">My Main Page</a></li></ul>
``:code

``rss``:inxx
使用 web2py 从存储的页面生成 RSS 订阅很容易是因为 web2py 包含 ``gluon.contrib.rss2``。只需将以下动作附加到默认控制器中:
``
def news():
    """generates rss feed from the wiki pages"""
    response.generic_patterns = ['.rss']
    pages = db().select(db.page.ALL, orderby=db.page.title)
    return dict(title='mywiki rss feed',
                link='http://127.0.0.1:8000/mywiki/default/index',
                description='mywiki news',
                created_on=request.now,
                items=[dict(title=row.title,
                            link=URL('show', args=row.id, scheme=True, host=True, extension=False),
                            description=MARKMIN(row.body).xml(),
                            created_on=row.created_on) for row in pages])
``:code

当你访问这个页面时
``
http://127.0.0.1:8000/mywiki/default/news.rss
``:code

您将会看到订阅(确定的输出取决于订阅的读者),注意字典被自动转换成 RSS,得益于URL 中的.rss 扩展。

[[image @///image/en4000.png center 480px]]

web2py 中包含 feedparser 用于读取第三方订阅。

注意这一行:

``
response.generic_patterns = ['.rss']
``:code

当URL以glob模式 ".rss"结束时，指示 web2py 使用通用视图(在我们的例子中是 "views/generic.rss")。默认情况下，通用视图只允许在localhost进行开发使用。

``XMLRPC``:inxx
最后,让我们添加一个 XML-RPC 处理程序,它允许以编程方式搜索 wiki:
``
service = Service()

@service.xmlrpc
def find_by(keyword):
    """finds pages that contain keyword for XML-RPC"""
    return db(db.page.title.contains(keyword)).select().as_list()

def call():
    """exposes all registered services, including XML-RPC"""
    return service()
``:code

这里,handler 动作只是发布(通过 XML-RPC)由``@service.xmlrpc``修饰的函数。本例中, ``find_by`` 不是一个动作(因为它需要一个参数),它使用 ``.select()`` 查询数据库,使用 ``.as_list()`` 提取记录作为一个列表并返回该列表。

下面是如何从外部 Python 程序访问 XML-RPC 处理程序的示例。

``
>>> import xmlrpclib
>>> server = xmlrpclib.ServerProxy('http://127.0.0.1:8000/mywiki/default/call/xmlrpc')
>>> for item in server.find_by('main'):
        print item['created_on'], item['title']
``:code

可以通过其它的编程语言访问 XML-RPC 处理程序,包括 C、 C++、 C#和 Java。

#### 关于 ``date``,  ``datetime``  和 ``time``  属性格式

每个字段类型的``date``、 ``datetime`` 和 ``time``有三种不同的表示形式:
- 数据库表示
- 内部 web2py 表示
- 表单和表中的字符串表示形式

数据库表示是一个内部问题并且不会影响代码。在内部,在 web2py 层面,它们分别被作为 ``datetime.date``、``datetime.datetime`` 以及  ``datetime.time`` 对象存储,可以如下操纵它们:

``
for page in db(db.page).select():
    print page.title, page.created_on.day, page.created_on.month, page.created_on.year
``

使用 ISO 表示将日期转换成表单中的字符串
``
%Y-%m-%d %H:%M:%S
``

但这种表示是国际化的而且你可以使用 admin 翻译页面将格式改为另一种格式。例如:

``
%m/%d/%Y %H:%M:%S
``

注意默认为英语不会被翻译,因为 web2py 假定应用已经用英语编写,如果想让国际化适用于英语,需要创建翻译文件(使用 admin)而且需要声明该应用的当前语言是除英语以外的其他东西,例如:
``
T.current_languages = ['null']
``

### 内置的web2py wiki

现在，您可以忘记上一节中内置的代码(不是您了解的web2py api，而是特定示例的代码)，因为我们将提供一个内置的web2py wiki示例。

事实上，web2py附带了wiki功能，包括媒体附件、标签、标签云、页面权限以及对oembed ``oembed``:cite 和组件的支持(第14章)。这个wiki可以用于任何web2py应用程序。

------
请注意，内置wiki的API仍然被认为是实验性的，小的更改仍然是可能的。
------

在这里，假设我们是从"welcome"应用程序简单克隆一个名为"wikidemo"的应用开始的。请确保在``db.py``文件中启用了迁移，否则将不会自动创建新的必需的wiki表。

编辑控制器并将 "index" 动作替换为。
``
def index(): return auth.wiki()
``:code

完成了!你有一个完整的wiki。
请注意，wiki需要定义一些表，它们只在访问控制器时定义。如果您想要它们随时可用，可以使用``auth.wiki(resolve=False)``，并确保打开了表迁移:下面的**Extending-the-auth-wiki-feature** 小节将对此进行详细介绍。

现在还没有创建页面，为了创建页面，您必须登录，并且必须是一个名为"wiki_editor"或"wiki_author"的组的成员。如果您以管理员身份登录，则会自动创建"wiki_editor"组，并成为成员。编辑者和作者的区别在于编辑者可以创建页面、编辑和删除任何页面，而作者可以创建页面(有一些可选的限制)，并且只能编辑/删除他们创建的页面。

``auth.wiki()`` 函数在字典中返回一个键 ``content``，基本构建 "views/default/index.html"可以理解为该键。你可以对这个动作提出自己的看法:

``
{{extend 'layout.html'}}
{{=content}}
``:code

并根据需要添加额外的HTML或代码。您不必使用"index" 动作来公开wiki。您可以使用具有不同名称的动作。

要尝试wiki，只需登录admin，访问页面

``
http://127.0.0.1:8000/wikidemo/default/index
``

然后选择一个slug(在出版业务中，slug是对生产中的一篇文章的简称)，你将被重定向到一个空白页面，在那里你可以使用MARKMIN wiki语法编辑内容。一个名为 "[wiki]" 的新菜单项将允许您创建、搜索和编辑页面。Wiki页面的url如下:

``
http://127.0.0.1:8000/wikidemo/default/index/[slug]
``

服务页面的名称以下划线开头:

``
http://127.0.0.1:8000/wikidemo/default/index/_create
http://127.0.0.1:8000/wikidemo/default/index/_search
http://127.0.0.1:8000/wikidemo/default/index/_could
http://127.0.0.1:8000/wikidemo/default/index/_recent
http://127.0.0.1:8000/wikidemo/default/index/_edit/...
http://127.0.0.1:8000/wikidemo/default/index/_editmedia/...
http://127.0.0.1:8000/wikidemo/default/index/_preview/...
``

尝试创建更多的页面，例如 "index"、 "aboutus"和"contactus"。
试着编辑它们。


 ``wiki`` 方法有以下参数:

``
def wiki(self, slug=None, env=None, render='markmin',
         manage_permissions=False, force_prefix='',
         restrict_search=False, resolve=True,
         extra=None, menu_groups=None)
``:code

它采用以下参数:

- ``render`` 默认为``'markmin'`` 但可以设置为``'html'``。它决定了wiki的语法。稍后我们将讨论markmin wiki。如果将其更改为HTML，可以使用wysiwyg javascript编辑器，比如TinyMCE或NicEdit。
- ``manage_permissions`` 默认设置为``False`` ，只识别"wiki_editor"和"wiki_author"的权限。如果您将其更改为``True`` ，则create/edit页面将提供按名称指定成员有权阅读和编辑页面的组的选项。有一组"everybody"包括所有用户。

- ``force_prefix`` 如果设置为 ``'%(id)s-'`` ，它将限制作者(而不是编辑者)创建前缀为"[用户id]-[页面名称]"的页面。前缀可以包含id ("%(id)s") 或用户名 ("%(username)s") 或auth_user表中的任何其他字段，只要对应的列包含传递URL验证的有效字符串。
- ``restrict_search`` 这默认为``False`` ，任何登录的用户都可以搜索所有的wiki页面(但不需要阅读或编辑它们)。如果设置为``True``，作者只能搜索自己的页面，编辑者可以搜索所有内容，其他用户不能搜索任何内容。
- ``menu_groups`` 默认为 ``None`` ，表示总是显示wiki管理菜单(搜索、创建、编辑等)。您可以将它设置为一个组名列表，其成员只能看到这个菜单，例如``['wiki_editor','wiki_author']``。请注意，即使菜单向所有人公开，这并不意味着每个人都可以执行菜单中列出的操作，因为它们是由访问控制系统控制的。

``wiki`` 方法还有一些附加参数，稍后将解释:``slug``、``env``和``extra``。



#### MARKMIN 基础知识

MARKMIN语法允许您使用``**粗体**``标记**粗体**文本、``''斜体''``标记''斜体''文本,并且``code``应该用双引号分隔。标题必须以#开头，部分以##结尾，子部分以##结尾。使用-(-)前缀非有序项，加上(+)前缀有序项。url被自动转换为链接。下面是一个markmin文本示例:

``
# This is a title
## this is a section title
### this is a subsection title

Text can be **bold**, ''italic'', !`!!`!code!`!!`! etc.
Learn more at:

http://web2py.com
``:code


您可以使用 ``auth.wiki`` 的 ``extra`` 参数。将额外的渲染规则传递给MARKMIN助手。

您可以在第5章中找到更多关于MARKMIN语法的信息。

``auth.wiki`` 比barebones MARKMIN助手更强大，它支持oembed和组件。

您可以使用 ``auth.wiki`` 的 ``env`` 参数。来向您的wiki公开函数。
例如:

``
auth.wiki(env=dict(join=lambda a:"-".join(a.split(","))))
``

允许您使用标记语法:

``
@{join:1,2,3}
``

这将调用传递给env的join函数，其参数为 ``"1,2,3"`` ，并将呈现为 ``1-2-3``。

#### Oembed 协议

您可以在wiki页面中键入(或剪切-粘贴)任何URL，并将其呈现为指向该URL的链接。也有例外:

- 如果URL有图像扩展，链接被嵌入到一个图像中， ``<img/>``。
- 如果URL有音频扩展，链接嵌入到HTML5 audio ``<audio/>``。
- 如果URL有视频扩展，链接被嵌入到HTML5 video  ``<video/>``。
- 如果URL有MS Office或PDF扩展名，则会嵌入谷歌Doc Viewer，显示文档的内容(仅适用于公共文档)。
- 如果URL指向YouTube页面、Vimeo页面或Flickr页面，web2py会联系相应的web服务，并询问嵌入内容的正确方式。这是使用“oembed”协议来完成的。

以下是一个完整的支持格式列表:
``
Image (.PNG, .GIF, .JPG, .JPEG)
Audio (.WAV, .OGG, .MP3)
Video (.MOV, .MPE, .MP4, .MPG, .MPG2, .MPEG, .MPEG4, .MOVIE)
``

支持通过谷歌Doc浏览器:

``
Microsoft Excel (.XLS and .XLSX)
Microsoft PowerPoint 2007 / 2010 (.PPTX)
Apple Pages (.PAGES)
Adobe PDF (.PDF)
Adobe Illustrator (.AI)
Adobe Photoshop (.PSD)
Autodesk AutoCad (.DXF)
Scalable Vector Graphics (.SVG)
PostScript (.EPS, .PS)
TrueType (.TTF)
xml Paper Specification (.XPS)
``:code

oembed的支持:

``
flickr.com
youtube.com
hulu.com
vimeo.com
slideshare.net
qik.com
polleverywhere.com
wordpress.com
revision3.com
viddler.com
``:code

这是在web2py文件``gluon.contrib.autolinks``中实现的，特别是在函数``expand_one``中。您可以通过注册更多的服务来扩展oembed支持。这是通过添加一个条目到 ``EMBED_MAPS`` 列表:

``
from gluon.contrib.autolinks import EMBED_MAPS
EMBED_MAPS.append((re.compile('http://vimeo.com/\S*'),
                   'http://vimeo.com/api/oembed.json'))
``:code

#### 引用 wiki 内容

如果您使用slug "contactus"创建一个wiki页面，您可以将该页面称为

``
\@////contactus
``:code

这里 @````//// 代表

``
\@/app/controller/function/
``:code

但是默认情况下， "app"、"controller"和"function"被省略。

类似地，您可以使用wiki菜单上传链接到页面的媒体文件(例如图片)。"管理媒体"页面将显示您上传的所有文件，并显示适当的表达式链接媒体文件。例如，如果您上传一个名为 "test.jpg" 的文件，标题为"beach"，链接表达式将如下所示:

``
\@////15/beach.jpg
``:code

``\@////`` 是前面描述的相同前缀。``15`` 是存储媒体文件的记录的id。 ``beach`` 是标题。``.jpg`` 是原始文件的扩展名。

如果您剪切和粘贴 ``\@////15/beach.jpg`` 到wiki页面，您就嵌入了图像。

请注意，媒体文件链接到页面继承来自页面的访问权限。

#### Wiki 菜单

如果你用slug "wiki-menu" 创建一个页面，它将被解释为菜单的描述。下面是一个例子:

``
- Home > \@////index
- Info > \@////info
- web2py > http://www.web2py.com
- - About us > \@////aboutus
- - Contact us > \@////contactus
``

每行有一个菜单项。我们对嵌套菜单项使用双破折号。 ``>`` 符号将菜单项标题与菜单项链接分开。

请注意，菜单被附加到 ``response.menu``后面。它不能取代它。带有服务功能的 ``[wiki]`` 菜单项会自动添加。

#### 服务功能

例如，如果您想使用wiki来创建一个可编辑的侧边栏，那么可以使用``slug="sidebar"``创建一个页面，然后嵌入到你的 layout.html 中

``
{{=auth.wiki(slug='sidebar')}}
``:code

注意， "sidebar"这个词没有什么特别之处。任何wiki页面都可以在代码的任何位置进行检索和嵌入。这允许您将wiki功能与常规的web2py功能混合并匹配。

------
还要注意，``auth.wiki('sidebar')``:code和 ``auth.wiki(slug='sidebar')``:code，因为slug kwarg是方法参数中的第一个。前者给出了稍微简单的语法。
------


您还可以嵌入特殊的wiki功能，例如通过标签搜索：

``
{{=auth.wiki('_search')}}
``:code

或者标签云:

``
{{=auth.wiki('_cloud')}}
``:code


#### 扩展 auth.wiki 功能

当支持wiki的应用程序变得更加复杂时，您可能需要定制由Auth接口管理的wiki db记录，或者为wiki CRUD任务公开定制的表单。例如，您可能希望定制一个wiki表记录表示或添加一个新的字段验证器。这在默认情况下是不允许的，因为wiki模型是在使用auth.wiki()方法请求wiki接口之后定义的。要访问应用程序模型中特定于wiki的db设置，您必须向模型文件(即db.py)添加以下语句

``
# 确保在创建auth实例后调用此函数
# 在对wiki表进行任何更改之前
auth.wiki(resolve=False)
``:code

通过在您的模型中使用上面的写法，wiki表将是可访问的(即 ``wiki_page``)，用于定制CRUD或其他db任务。

------
注意，为了公开wiki接口，仍然需要在控制器或视图中调用auth.wiki()，因为 ``resolve=False`` 参数指示auth对象在没有任何其他接口设置的情况下只构建wiki模型。
------


另外，通过在方法调用中将resolve设置为 ``False``，现在可以通过应用程序的默认db接口``<app>/appadmin``访问wiki表，用于管理wiki记录。


另一种可能的定制是将额外的字段添加到标准wiki表（与第9章中描述的 ``auth_user`` 表相同）。以下是：

``
# 在auth对象初始化之后放置
auth.settings.extra_fields["wiki_page"] = [Field("ablob", "blob"), ]
``:code

上面的一行将 ``blob`` 字段添加到``wiki_page``表中。不需要调用 ``auth.wiki(resolve=False)``:code，除非您需要访问wiki模型来进行其他定制。


#### 组件

新Web2Py最强大的功能之一是将动作嵌入到另一个动作中的能力。我们称之为组件。

仔细考虑以下模型：

``
db.define_table('thing', Field('name', requires=IS_NOT_EMPTY()))
``:code

及下列动作:

``
@auth.requires_login()
def manage_things():
    return SQLFORM.grid(db.thing)
``:code

这个动作是特殊的，因为它返回一个小部件/帮助器而不是一个字典对象。现在我们可以把这个``manage_things``的动作嵌入到任何视图中。

``
{{=LOAD('default', 'manage_things', ajax=True)}}
``:code

这允许访问者通过Ajax与组件交互，而无需重新加载嵌入小部件的父页面。该操作通过Ajax调用，继承父页面的样式，捕获所有表单提交和flash消息，以便在当前页面中处理它们。在此之上``SQLFORM.grid`` 小部件使用数字签名url来限制访问。关于组件的更多信息可以在第13章找到。

像上面这样的组件可以使用MARKMIN语法嵌入到wiki页面中:

``
@{component:default/manage_things}
``

这只是告诉web2py，我们希望将 "default" 控制器中的 "manage_things" 动作定义为Ajax "组件"。

---------
大多数用户只需使用 ``auth.wiki``就能够构建相对复杂的应用程序，创建页面和菜单并将定制组件嵌入到wiki页面中。Wiki可以被认为是一种允许组成员创建页面的机制，但也可以被认为是一种以模块化的方式开发应用程序的方法。
---------

###关于 **admin** 的更多内容
``admin``:inxx

管理界面提供了附加功能,我们这里简要回顾。

#### Site 页面
``site``:inxx

这个页面是web2py的主要管理界面。它在左边列出了所有已安装的应用程序，而在右边有一些特殊的操作表单。

第一个是web2py版本，如果有新版本可用，建议升级。当然，升级之前一定要有一个完整的工程备份!
另外还有两种形式允许通过指定新应用程序的名称来创建新应用程序(简单的或通过使用在线向导)。

``Instant Press``:inxx ``Movuca``:inxx
在往下的表单允许从本地文件或远程URL上传已有应用程序。上传应用程序时，需要为其指定一个名称(使用不同的名称,
允许您安装同一应用程序的多个副本)。例如，你可以尝试上传由Bruno Rocha创建的Movuca社交网络应用程序:

``
https://github.com/rochacbruno/Movuca
``

或者是Martin Mulone创建的即时新闻CMS:

``
http://code.google.com/p/instant-press/
``

或众多示例应用程序之一::

``
http://web2py.com/appliances
``

------
Web2py 文件打包成 ``.w2p`` 文件。这些是 tar gzip 压缩文件,Web2py 使用 ``.w2p`` 扩展代替 ``.tgz`` 扩展来防止浏览器下载之后解压,它们可以使用``tar xzvf [filename]`` 手动解压它们,尽管从来没有必要这么做。
------

[[image @///image/en4100.png center 444px]]

成功上传之后,web2py 显示上传文件的 MD5 校验,可以用它验证文件在上传过程中有没有被损坏。应用程序名称将出现在已安装的应用程序列表中。

如果您从源代码运行web2py，并且安装 ``gitpython`` (如果需要，使用'easy_install gitpython'安装它)，您可以直接从git存储库安装应用程序
使用上传表单中的 ``.git`` URL。在这种情况下，您还可以使用admin接口将更改推回到存储库，但这是一个实验性的特性。

例如，您可以使用URL在web2py site上本地安装这本书的应用程序:

``
https://github.com/web2py/web2py-book.git
``

------
这个存储库承载了这本书的最新版本(可能与您在网站上看到的稳定版本不同)。
我们诚挚地邀请您使用它以pull request的形式提交改进、修复和更正。
------

对于安装的每个应用程序，您可以使用 ''site'' 页面:
- 直接点击它的名字进入应用程序。
- 卸载应用程序。
- 跳转到''about''页(阅读下文)。
- 跳转到 ''edit'' 页(阅读下文)。
- 跳转到''errors'' 页(读下面)。
- 清理临时文件(会话、错误和缓存文件)。
- 打包全部。这返回一个包含完整应用副本的 tar 文件,我们建议在打包应用之前清理临时文件。
- 编译应用程序。如果没有错误,该选项将会字节码编译 (bytecode-compiles)所有模型,控制器和视图。因为视图可以在树中扩展和包含其它视图,所以在字节码编译之前,每个控制器的视图树都被折叠成一个单一的文件,最终的结果是一个字节码编译应用,其速度更快,因为在运行时不再需要模版解析和替换字符串。
- 包编译。此选项仅存在于字节码编译完成的应用程序中。它它允许将没有源代码的应用程序打包为封闭源代码进行发布。注意，Python（和其他任何编程语言一样）在技术上都可以反编译；因此编译不能提供对源代码的完全保护。然而，反编译可能很困难，也可能是非法的。
- 移除已编译。它只是从应用程序中删除字节码编译的模型、视图和控制器。如果应用程序打包了源代码或在本地进行了编辑，那么删除字节码编译后的文件并没有什么害处，应用程序将继续工作。如果应用程序是从一个打包的编译文件中安装的，那么这是不安全的，因为没有源代码可以还原，应用程序将不再工作。

``admin.py``:inxx

-------
web2py admin管理站点页面提供的所有功能也可以通过模块 ``gluon/admin.py``中定义的API以编程方式访问。简单地打开一个python shell并导入这个模块。
-------

如果安装了谷歌应用程序引擎SDK，管理 ''site'' 页面将显示一个按钮，将应用程序推到GAE。如果安装了 ``python-git`` ，还会有一个按钮来推动应用程序部署到``OpenShift``。要在 ``Heroku`` 或其他托管系统上安装应用程序，您应该查看 "scripts" 文件夹，寻找合适的脚本。

#### About 页面
``about``:inxx ``license``:inxx

 ''about''选项卡允许编辑应用程序及其许可证的描述。它们分别被写入应用文件夹中的 ABOUT 和 LICENSE 文件中。

[[image @///image/en4300.png center 480px]]

你可以在这些文件用 ``MARKMIN``或 ``gluon.contrib.markdown.WIKI`` 语法,正如参考中描述的``markdown2``:cite。

#### Design 页面
``EDIT``:inxx
您已经在本章中使用了 ''edit'' 页面。在这里，我们想指出 ''edit'' 页面的更多功能。
- 如果您点击任何文件名，您可以看到文件的内容与语法高亮显示。
- 如果您点击 edit(编辑)，您可以通过 web 界面编辑文件。
- 如果你点击 delete(删除)，您可以删除文件(永久)。
- 如果您点击 test(测试), web2py会运行测试。测试是由开发人员使用Python doctests编写的，每个函数都应该有自己的测试。
- 您可以添加语言文件，扫描应用程序发现所有字符串，并通过 web 界面编辑字符串翻译。
- 如果静态文件被组织在文件夹和子文件夹中，可以通过单击文件夹名称来切换文件夹层次结构。

下图显示了 welcome 应用程序的测试页面的输出。

[[image @///image/en4400.png center 480px]]

下图显示了 welcome 应用程序的语言选项卡。

[[image @///image/en4500.png center 480px]]

下图显示了如何编辑语言文件，在本例中是 welcome 应用程序的 "it" (意大利语)语言。

[[image @///image/en4600.png center 480px]]

#### 集成基于web的调试器

''(需要Python 2.7或更高版本)''

web2py admin 管理包括一个基于web的调试器。
``debugger``:inxx
使用提供的基于web的编辑器，您可以将断点添加到Python代码中，并且从相关的调试器控制台，您可以在这些断点处检查系统变量并继续执行。如下截图所示:
交互控制台还可以用作Python暂存器。

[[image @///image/debugger.png center 480px]]

此功能基于Mariano Reingart创建的Qdb调试器。
它使用多进程连接来在后端之间进行通信。
前端采用 JSON-RPC-like 流协议。 ``qdb``:cite

##### 通过代码设置断点
``breakpoints``:inxx
包括:
``
from gluon.debug import dbg
``:code

要进入调试器，请将其放入所需的位置:
``
dbg.set_trace()
``:code

调试器应用程序有一个断点管理器。

------
注:
web2py不知道在浏览器中是否打开了调试窗口;执行中止。
IDE通常有自己的进程间调试器，例如 PyCharm 或 PyDev 。如果包含 gluon 库，他们可能会抱怨。
------


#### 基于web的 Python shell

如果单击 ''edit''中的 controllers 控制器选项卡下的 "shell" 链接，web2py将打开一个基于web的Python shell，并为当前应用程序执行模型。这允许您与应用程序进行交互。

[[image @///image/en4700.png center 480px]]

-------
使用基于web的shell时要小心——因为不同的shell请求将在不同的线程中执行。这很容易导致错误，尤其是在使用数据库时
创建和连接。对于这样的活动(例如，如果您需要持久性)，最好使用python命令行。
-------
#### Crontab

在 ''edit'' 中的controllers控制器选项卡下还有一个 "crontab" 链接。通过单击这个链接，您将能够编辑web2py crontab文件。它遵循与Unix crontab相同的语法，但不依赖于Unix。实际上，它只需要web2py，并且能在Windows上运行。它允许您注册需要在预定时间在后台执行的动作。
有关这方面的更多信息，请参阅下一章。

#### Errors
``errors``:inxx

在编写web2py时，不可避免地会犯错误并引入错误。web2py提供了两方面的帮助:1)它允许您为浏览器中可以从 ''edit'' 页面运行的每个函数创建测试;2)当出现错误时，向访问者发出票据并记录错误。

有意在 images 应用程序中引入一个错误，如下所示:
``
def index():
    images = db().select(db.image.ALL, orderby=db.image.title)
    1/0
    return dict(images=images)
``:code

当您访问 index 动作时，您将得到以下票据:

[[image @///image/en4800.png center 480px]]

只有管理员可以访问票据:

[[image @///image/en4900.png center 480px]]

票据显示回溯,文件的内容引发了问题和系统的完整状态(变量、请求、会话等),如果错误出现在视图中,web2py 显示从 HTML 转换成 Python 代码的视图,这可以很轻松地确定文件的逻辑结构。

默认情况下，票据存储在文件系统上，并按回溯分组显示。管理接口界面提供了一个聚合视图(回溯类型和发生的次数)和一个详细视图(所有的票据都按票据 id 列出)。管理员可以在两个视图之间切换。

注意 **admin** 处显示语法高亮的代码(例如，在错误报告中，web2py关键字以橙色显示)。如果您单击web2py关键字，您将被重定向到关于该关键字的文档页面。

如果您在 index 动作中修复了除以零的错误并在 index 视图中引入一个:
``
{{extend 'layout.html'}}

<h1>Current Images</h1>
<ul>
{{for image in images:}}
{{1/0}}
{{=LI(A(image.title, _href=URL("show", args=image.id)))}}
{{pass}}
</ul>
``:code

你会得到如下票据:

[[image @///image/en5000.png center 480px]]

注意 web2py 将视图从HTML转换为Python文件，票据中描述的错误是指生成的Python代码，而不是原始视图文件:

[[image @///image/en5100.png center 480px]]

乍一看，这似乎有些令人困惑，但实际上它使调试更容易，因为Python缩进突出显示了嵌入到视图中代码的逻辑结构。

代码显示在同一页面的底部。

所有的票据都在 admin 下的每个应用程序的 ''errors'' 错误页面被列出:

[[image @///image/en5200.png center 480px]]

#### Mercurial （轻量级分布式版本控制系统）
``Mercurial``:inxx

如果从源代码开始运行，管理界面会显示一个名为 "Versioning" 版本控制的菜单项。

[[images @///image/en5300.png center 480px]]

在结果页面中输入注释并按下 "commit" 按钮将提交当前应用程序。有了第一个提交，本地的 Mercurial 存储库就有了
将创建的应用程序
在幕后，Mercurial 将关于您在代码中所做更改的信息存储在一个隐藏文件夹中。在你的应用子文件夹里。每个应用都有自己的 ".hg" 文件夹和它自己的 ".hgignore" 文件(告诉 Mercurial 忽略哪些文件)。
为了使用这个特性，您必须安装 Mercurial 版本控制库(最低1.9 版本):


``
pip install mercurial
``:code

Mercurial web界面确实允许您浏览以前的提交和 diff 文件，但我们确实建议您直接从 shell 或许多基于GUI的 Mercurial 客户机中使用 Mercurial ，因为它们更强大。例如，它们将允许您将应用程序与远程资源存储库同步。



可以在如下地址读到更多关于 Mercurial 的信息:
``
http://mercurial.selenic.com/
``

#### Git 工具(Git integration)
``git``:inxx
admin 管理应用程序还包括git integration。需要 Python git库，例如。
``
pip install gitpython
``:code

然后，对于每个应用程序，您必须克隆或配置git存储库。

在这些步骤之后，每个 git-managed 应用程序的 Manage 菜单将显示 git push 和 git pull。
未由git管理的应用程序将被忽略。
您可以从默认远程存储库中pull（提取）和push（推送）应用程序。


#### 应用程序向导(实验性的)

**admin** 界面包含一个向导，可以帮助您创建新的应用程序。
您可以从 "site" 页面访问向导，如下图所示。

[[image @///image/en5400.png center 480px]]

向导将指导您完成创建新应用程序所涉及的一系列步骤:

- 为应用程序选择名称
- 配置应用程序并选择所需的插件
- 构建所需的模型(它将为每个模型创建CRUD页面)
- 允许您使用 MARKMIN 语法编辑这些页面的视图

下图显示了这个过程的第二步。

[[image @///image/en5500.png center 480px]]

你会看到一个下拉菜单来选择一个布局插件(从``web2py.com/layouts``),一个多选下拉菜单来查看其它插件(从  ``web2py.com/plugins``),还有一个 "login config" 字段在那儿放置的 Janrain "domain:key"。

其他步骤都是不言自明的。

该向导的工作性能很好，但它被认为是一个 ''实验特性'' ，原因有二:

- 使用向导创建并手动编辑的应用程序以后不能被向导修改。
- 随着时间的推移，向导的界面将会改变，包括支持更多特性和更容易的可视化开发。

在任何情况下，向导都是一个用来制作快速原型的方便工具，它可以用来引导一个新的应用程序，带有备用布局和可选插件。

#### 配置 **admin**

通常不需要执行任何 **admin** 的配置，但是可以进行一些定制。登录admin后，可以通过URL编辑admin配置文件:
``
http://127.0.0.1:8000/admin/default/edit/admin/models/0.py
``
注意，可以使用 **admin** 来编辑自己。实际上，**admin** 是一个与其它任何应用一样的应用。

文件 "0.py" 在很大程度上是自我记录，不管怎样，下面是一些最重要的定制:

``
GAE_APPCFG = os.path.abspath(os.path.join('/usr/local/bin/appcfg.py'))
``
这应该指向 "appcfg.py"文件的位置,该文件附带 Google App Engine SDK。如果已安装了 SDK 你可能需要将配置参数改为正确的值,这将允许你从 admin 界面部署到 GAE。

``DEMO_MODE``:inxx

您还可以在演示模式下设置 web2py admin:
``
DEMO_MODE = True
FILTER_APPS = ['welcome']
``
并且只有FILTER_APPS中列出的应用程序是可访问的，并且它们只能在只读模式下可访问。

``MULTI_USER_MODE``:inxx
``virtual laboratory``:inxx

如果您是一名教师，需要向学生公开管理界面，以便学生能够为他们的项目共享一个管理界面(可认为是虚拟实验室)，可以通过设置:
``
MULTI_USER_MODE = True
``
通过这种方式，学生需要登录，并且只能通过管理员访问自己的应用程序。作为第一个用户/教师，您将能够访问全部应用。

在多用户模式下，您可以使用admin中的"bulk register"("批量注册")链接注册学生，并使用"manage students"("管理学生")链接管理学生。系统还记录学生登录的时间，以及他们在代码中添加/删除了多少行代码。这些数据在应用程序 "about"页面下以图表的形式呈现给管理员。

请注意，此机制仍然假设所有用户都是可信的。在admin下创建的所有应用程序都运行在同一个文件系统上以相同的凭据。一个学生创建的应用程序可以访问另一个学生创建的应用程序的数据和源代码。学生也可以创建一个锁定服务器的应用程序。

#### 移动端 **admin**

注意，admin 应用程序包括 "plugin_jqmobile" ，它将jQuery Mobile打包。当从移动设备访问admin时，web2py会检测到这一点，并使用移动友好的布局显示界面:

[[image @///image/mobile.png center 306px]]

### 更多关于 **appadmin**

``appadmin``:inxx

**appadmin**不打算公开给公众。它旨在通过提供对数据库的简单访问来帮助您。它只包含两个文件:一个控制器 "appadmin.py" 和一个视图 "appadmin.html" ,它们被控制器中的所有动作使用。

**appadmin**控制器相对较小且可读;它提供了一个设计数据库接口的示例。

**appadmin** 显示哪些数据库可用，以及每个数据库中存在哪些表。您可以插入记录并单独列出每个表的所有记录。**appadmin** 每次分页输出100条记录。

一旦选择了一组记录，页头就会改变，允许您更新或删除所选的记录。

要更新记录，在查询字符串字段中输入SQL赋值:
``
title = 'test'
``:code

其中字符串值必须用单引号括起来。多个字段可以用逗号分隔。

若要删除记录，请单击相应的复选框以确认您是否确定删除。

如果查询包含一个、两个或多个表的SQL条件，则 **appadmin** 还可以执行连接。例如,尝试:
``
db.image.id == db.post.image_id
``:code

web2py把这个传递给 DAL,它理解该查询链接的两个表;因此,两个表都被 INNER JOIN 内部连接选中。下面是输出:

[[image @///image/en5600.png center 480px]]

如果您单击 id 字段的编号，您将获得具有相应id的记录的编辑页面。

如果单击引用字段的编号，就会得到引用记录的编辑页面。

您不能更新或删除由联接查询选择的行，因为它们涉及来自多个表的记录，这将是含糊不清的。

除了数据库管理功能， **appadmin** 还可以查看应用程序的``cache`` (在``/yourapp/appadmin/cache``处)以及当前 ``request``(请求)’、``response``(响应)和``session``(在``/yourapp/appadmin/state``)’对象的内容。

**appadmin**用自己的菜单取代``response.menu`` ,它提供了到 **admin**应用的 **edit** 界面、**db**(数据库管理)界面、**state** 界面和 **cache** 界面的链接。如果你的应用布局没有使用``response.menu`` 生成菜单,那么您将不会看到 **appadmin** 菜单。在这种情况下,您可以修改 appadmin.html 文件并添加``{{=MENU(response.menu)}}``来显示菜单。
