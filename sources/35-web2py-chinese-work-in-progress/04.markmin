## 核心

[[CommandLineOptions]]
### 命令行选项

可以跳过 GUI 直接从命令行启动 web2py,输入如下内容:
``password``:inxx

``
python web2py.py -a 'your password' -i 127.0.0.1 -p 8000
``:code

当web2py启动时，它会创建一个名为 "parameters_8000.py"的文件。它存储哈希密码的地方。如果您使用"<ask>"作为密码，web2py会提示您输入密码。

要获得额外的安全性，您可以使用以下命令启动web2py:
``
python web2py.py -a '<recycle>' -i 127.0.0.1 -p 8000
``:code

在本例中，web2py重用了先前存储的哈希密码。如果没有提供密码，或者"parameters_8000.py"文件被删除，基于web的管理界面会被禁用。

``PAM``:inxx
一些 Unix/ Linux 系统上,如果密码是
``
<pam_user:some_user>
``:code

web2py使用``some_user``操作系统帐户的PAM密码对管理员进行身份验证，除非被PAM配置阻止。

-------
web2py通常与CPython(由Guido van Rossum创建的C语言实现Python解释器)一起运行，但它也可以与PyPy和Jython一起运行。后一种可能性允许web2py在Java EE基础架构中使用。要使用Jython，只需替换"python web2py.py ..."为"jython web2py.py"。关于安装Jython、访问数据库所需的 zxJDBC 模块的详细信息可以在第14章中找到。
-------

"web2py.py"脚本可以接受许多命令行参数，指定线程的最大数量，启用SSL等等。如下获取完整列表:

``command line``:inxx
``
>>> python web2py.py -h
Usage: python web2py.py

web2py Web Framework startup script. ATTENTION: unless a password
is specified (-a 'passwd'), web2py will attempt to run a GUI.
In this case command line options are ignored.

Options:
  --version             show program's version number and exit
  -h, --help            show this help message and exit
  -i IP, --ip=IP        IP address of the server (e.g., 127.0.0.1 or ::1);
                        Note: This value is ignored when using the
                        'interfaces' option.
  -p PORT, --port=PORT  port of server (8000)
  -a PASSWORD, --password=PASSWORD
                        password to be used for administration (use -a
                        "<recycle>" to reuse the last password))
  -c SSL_CERTIFICATE, --ssl_certificate=SSL_CERTIFICATE
                        file that contains ssl certificate
  -k SSL_PRIVATE_KEY, --ssl_private_key=SSL_PRIVATE_KEY
                        file that contains ssl private key
  --ca-cert=SSL_CA_CERTIFICATE
                        Use this file containing the CA certificate to
                        validate X509 certificates from clients
  -d PID_FILENAME, --pid_filename=PID_FILENAME
                        file to store the pid of the server
  -l LOG_FILENAME, --log_filename=LOG_FILENAME
                        file to log connections
  -n NUMTHREADS, --numthreads=NUMTHREADS
                        number of threads (deprecated)
  --minthreads=MINTHREADS
                        minimum number of server threads
  --maxthreads=MAXTHREADS
                        maximum number of server threads
  -s SERVER_NAME, --server_name=SERVER_NAME
                        server name for the web server
  -q REQUEST_QUEUE_SIZE, --request_queue_size=REQUEST_QUEUE_SIZE
                        max number of queued requests when server unavailable
  -o TIMEOUT, --timeout=TIMEOUT
                        timeout for individual request (10 seconds)
  -z SHUTDOWN_TIMEOUT, --shutdown_timeout=SHUTDOWN_TIMEOUT
                        timeout on shutdown of server (5 seconds)
  --socket-timeout=SOCKET_TIMEOUT
                        timeout for socket (5 second)
  -f FOLDER, --folder=FOLDER
                        location of the applications folder (also known as directory)
  -v, --verbose         increase --test verbosity
  -Q, --quiet           disable all output
  -D DEBUGLEVEL, --debug=DEBUGLEVEL
                        set debug output level (0-100, 0 means all, 100 means
                        none; default is 30)
  -S APPNAME, --shell=APPNAME
                        run web2py in interactive shell or IPython (if
                        installed) with specified appname (if app does not
                        exist it will be created). APPNAME like a/c/f (c,f
                        optional)
  -B, --bpython         run web2py in interactive shell or bpython (if
                        installed) with specified appname (if app does not
                        exist it will be created). Use combined with --shell
  -P, --plain           only use plain python shell; should be used with
                        --shell option
  -M, --import_models   auto import model files; default is False; should be
                        used with --shell option
  -R PYTHON_FILE, --run=PYTHON_FILE
                        run PYTHON_FILE in web2py environment; should be used
                        with --shell option
  -K SCHEDULER, --scheduler=SCHEDULER
                        run scheduled tasks for the specified apps: expects a
                        list of app names as -K app1,app2,app3 or a list of
                        app:groups as -K app1:group1:group2,app2:group1 to
                        override specific group_names. (only strings, no
                        spaces allowed. Requires a scheduler defined in the
                        models
  -X, --with-scheduler  run schedulers alongside webserver
  -T TEST_PATH, --test=TEST_PATH
                        run doctests in web2py environment; TEST_PATH like
                        a/c/f (c,f optional)
  -C, --cron            trigger a cron run manually; usually invoked from a
                        system crontab
  --softcron            triggers the use of softcron
  -Y, --run-cron        start the background cron process
  -J, --cronjob         identify cron-initiated command
  -L CONFIG, --config=CONFIG
                        config file
  -F PROFILER_DIR, --profiler=PROFILER_DIR
                        profiler dir
  -t, --taskbar         use web2py gui and run in taskbar (system tray)
  --nogui               text-only, no GUI
  -A ARGS, --args=ARGS  should be followed by a list of arguments to be passed
                        to script, to be used with -S, -A must be the last
                        option
  --no-banner           Do not print header banner
  --interfaces=INTERFACES
                        listen on multiple addresses: "ip1:port1:key1:cert1:ca
                        _cert1;ip2:port2:key2:cert2:ca_cert2;..."
                        (:key:cert:ca_cert optional; no spaces; IPv6 addresses
                        must be in square [] brackets)
  --run_system_tests    runs web2py tests
``:code

------
请注意:
- ``-W``选项，用于安装Windows服务，已被删除。请参阅[[nssm在部署方法章节的内容../13#nssm]]
- Profiler输出可以使用``runsnakerun``工具进行分析
------

小写选项用于配置web服务器。 ``-L`` 选项告诉web2py从文件中读取配置选项，而``-S``、``-P``和``-M``选项启动一个交互式Python shell。``-T``选项在web2py执行环境中查找并运行控制器doctests。例如，下面的示例从"welcome"应用程序中的所有控制器运行doctest:
``
python web2py.py -vT welcome
``:code

### 工作流程

web2py 工作流程如下:
- HTTP请求到达web服务器(内置的Rocket server或通过WSGI或其他适配器连接到web2py的不同服务器)。web服务器并行地在自己的线程中处理每个请求。
- HTTP请求头被解析并传递给dispatcher调度器(本章稍后将对此进行解释)。
- 调度器将决定由哪一个安装应用处理请求，并将URL中的PATH_INFO映射到函数调用中。每个URL对应于一个函数调用。
- 对于静态文件夹中的文件请求被直接处理,并且大文件被自动地流式传输到客户端。
- 除了静态文件之外的任何请求都被映射到一个动作(即在请求的应用程序中控制器文件中的一个函数)。
- 在调用动作之前，会发生一些事情:如果请求头包含应用程序的会话cookie，就会检索会话对象;如果没有，则创建会话id(但是会话文件要等到稍后保存);创建请求的执行环境;模型在这个环境中执行。
- 最后,控制器动作在预先构建的环境中执行。
- 如果动作返回一个字符串，它将返回给客户端(或者如果动作返回一个web2py HTML帮助对象，它将被序列化并返回给客户端)。
- 如果动作返回一个可迭代工作流,它被用来循环并将数据分流传送到客户端。
- 如果动作返回一个字典,web2py 会试图找到一个视图呈现该字典,视图必须与动作名称相同(除非另有规定)并且扩展名与被请求的页面相同(默认为.html);失败的话,web2py 可能采用通用视图(如果可用并且已启用),视图看到定义在模型中和由动作返回的字典中的每个变量,但没有看到在控制器中定义的全局变量。
- 除非另有说明，整个用户代码在一个数据库事务中执行。
- 如果用户代码成功，则提交事务。
- 如果用户代码失败，则回溯存储在票据中，并向客户端发出票据ID。只有系统管理员才能搜索和读取票据中的回溯。

有一些注意事项需要记住:
- 同一文件夹/子文件夹中的模型按字母顺序执行。
- 模型中定义的任何变量对按字母顺序的模型、控制器和视图都是可见的。
``models_to_run``:inxx
``conditional models``:inxx
[[conditional_models]]
#### 条件模型
- 子文件夹中的模型根据使用中的控制器有条件地执行。这避免了在每个请求时处理所有表定义。例如，如果用户请求"/a/c/f"，其中"a"为应用程序，"c"为控制器，"f"为函数(动作)，那么如下模型会被执行:

``
applications/a/models/*.py
applications/a/models/c/*.py
applications/a/models/c/f/*.py
``
  默认情况下执行此行为。改变``response.models_to_run`` 正则表达式列表，您可以强制执行您想要的行为。查看[[response #response_models_to_run]]了解更多细节

- 执行请求的控制器并调用请求的函数。这意味着控制器中的所有顶级代码也会在每次请求该控制器时执行。
- 只有当动作返回字典时才调用视图。
- 如果没有找到视图，web2py会尝试使用通用视图。默认情况下，通用视图是禁用的，尽管'welcome'应用程序在/models/db.py中包含一行代码。该代码在 localhost 上启用它们。它们可以在每个扩展类型和每个动作中启用(使用``response.generic_patterns``)。一般来说，通用视图是一种开发工具，通常不应该在生产环境中使用。如果您想要一些动作使用通用视图，请在``response.generic_patterns``中列出这些动作(更多细节在 Services 章节中讨论)。

动作的可能行为有以下几种:

**返回一个字符串**
``
def index():
    return 'data'
``

**为视图返回一个字典**:
``
def index():
    return dict(key='value')
``

**返回所有局部变量**:
``
def index():
    return locals()
``

**将用户重定向到另一个页面**:
``
def index():
    redirect(URL('other_action'))
``

**返回 "200 OK"之外的 HTTP 页面**:
``
def index():
    raise HTTP(404)
``

**返回一个帮助对象(例如,一个表单):
``
def index():
    return FORM(INPUT(_name='test'))
``
(这主要用于 Ajax 回调和组件,请参阅第 12 章)

当一个动作返回一个字典时，它可能包含由帮助对象生成的代码，包括基于数据库表的表单或来自工厂的表单，例如:

``
def index():
    return dict(form=SQLFORM.factory(Field('name')).process())
``
(web2py 生成的所有表单都使用页面回传,见第 3 章)

### 调度
``url mapping``:inxx ``dispatching``:inxx

web2py 将映射成如下 形式 的 URL:

``
http://127.0.0.1:8000/a/c/f.html
``:code

对于应用 "a" 控制器 "c.py" 中的函数 ``f()`` ,如果 ``f``不存在,web2py 默认使用``index``控制器函数;如果 c 不存在,web2py 默认使用"default.py"控制器;并且如果 ``a`` 不存在,web2py 默认使用 ``init`` 应用;如果没有 init 应用, web2py 尝试运行 ``welcome`` 应用。如下图所示:

[[image @///image/en5700.png center 480px]]

默认情况下,任何新请求都创建一个新会话。除此之外,会话 cookie 被返回客户端浏览器来追踪会话。

扩展名 ``.html``是可选的, ``.html``被假定为默认,该扩展名决定了用于呈现控制器函数 ``f()``的输出的视图的扩展名,它允许以多种格式(html、 xml、 json、 rss 等)提供相同的内容。

-------
带参数或双下划线开始的函数是不公开的并且只能由其它函数调用。
-------

``static files``:inxx
对于表单的url有例外:
``
http://127.0.0.1:8000/a/static/filename
``:code

没有所谓的"static"控制器。web2py将此解释为对应用程序"a"的"static"子文件夹中名为"filename"的文件的请求。

``PARTIAL CONTENT``:inxx ``IF_MODIFIED_SINCE``:inxx
当下载静态文件时，web2py不会创建会话，也不会发出cookie或执行模型。web2py总是以1MB的块数据流静态文件，当客户端发送 RANGE 请求文件的一个子集时，它会发送PARTIAL CONTENT。

web2py还支持IF_MODIFIED_SINCE协议，如果文件已经存储在浏览器的缓存中，并且该版本之后文件没有改变，则不发送文件。

当连接到静态文件夹中的音频或视频文件时，如果你想强迫浏览器下载文件而不是通过媒体播放器播放音频/视频，添加 ``?attachment`` 到URL。这告诉web2py将HTTP响应的Content-Disposition头设置为附件"attachment"。例如:

``
<a href="/app/static/my_audio_file.mp3?attachment">Download</a>
``:code

当点击上面的链接时，浏览器将提示用户下载MP3文件，而不是立即播放音频。(如[[下面的 #response]]所讨论的，您还可以通过将标头名称及其值的``dict``赋值给``response.headers``来直接设置HTTP请求标头。)

``request.application``:inxx ``request.controller``:inxx ``request.function``:inxx ``GET``:inxx ``POST``:inxx ``request.args``:inxx
web2py 映射如下形式的 GET/POST 请求:
``
http://127.0.0.1:8000/a/c/f.html/x/y/z?p=1&q=2
``:code

到应用``a``控制器 "c.py"中的函数``f``,并且它在``request``变量中存储 URL 参数如下:
``
request.args = ['x', 'y', 'z']
``:code

和:
``
request.vars = {'p': 1, 'q': 2}
``:code

以及:
``
request.application = 'a'
request.controller = 'c'
request.function = 'f'
``:code

在上面的例子中,``request.args[i]``和 ``request.args(i)``)都能用来检索``request.args``的第 i 个元素,如果列表没有这样的索引,前者会引发异常,后者在这种情况下返回 None。

``request.url``:inxx
``
request.url
``:code

存储当前请求的完整 URL(不包括 GET 变量)。

``request.ajax``:inxx ``request.cid``:inxx

``
request.ajax
``:code

默认为 False,但如果 web2py 决定动作是 Ajax 请求调用的,它就是 True。

如果请求是 Ajax 请求并且是由 web2py 组件发起的,可以找到该组件的名称:

``
request.cid
``:code

第12章将更详细地讨论组件。

``request.get_vars``:inxx ``request.post_vars``:inxx ``request.vars``:inxx
如果HTTP请求是GET，那么``request.env.request_method`` 设置为 "GET";如果是POST，``request.env.request_method``设置为 "POST"。
URL查询变量存储在``request.get_vars``中。
``request.post_vars``包含传递到请求主体(通常是POST、PUT或DELETE)的所有参数。
``request.vars`` 存储字典包含这两者(``get_vars``和 ``post_vars``的合并)

web2py在 ``request.env``中存储 WSGI 和 web2py 环境变量,例如:
``
request.env.path_info = 'a/c/f'
``:code

和 HTTP 头到环境变量,例如:
``
request.env.http_host = '127.0.0.1:8000'
``:code

-------
请注意,web2py 验证所有的 URL 以防止目录遍历攻击。
-------

url只允许包含字母数字字符、下划线和斜线; ``args`` 可能包含非连续点。在验证之前，空格被下划线替换。如果URL语法无效，web2py返回一个HTTP 400错误消息``http-w``:cite ``http-o``:cite 。

如果URL对应一个静态文件的请求，web2py只是读取并返回请求的文件(流式传输)。

如果URL不请求静态文件，web2py将按照以下顺序处理请求:
- 解析 cookie。
- 创建执行函数的环境
- 初始化``请求``、``响应``、``缓存``。
- 打开现有``session``或创建一个新的``session``。
- 执行属于所要求的应用程序的模型。
- 执行请求的控制器动作函数。
- 如果该函数返回一个字典,则执行关联的视图。
- 如果成功,提交所有开放事务。
- 保存会话session。
- 返回一个 HTTP 响应。

注意，控制器和视图在相同环境的不同副本中执行;因此，视图看不到控制器，但它看到的是模型和控制器动作函数返回的变量。

如果引发异常(HTTP除外),web2py 会执行以下操作:
- 在错误文件中存储回溯并为其分配一个票据号。
- 回滚所有开放事务。
- 返回一个报告票据号的错误页面。

如果异常是``HTTP`` 异常，则假定这是预期的行为(例如， ``HTTP`` 重定向)，并提交所有数据库事务。之后的行为由``HTTP`` 异常本身指定。``HTTP`` 异常类不是标准的Python异常;它由web2py定义。

### 库

web2py库作为全局对象公开给用户应用程序。例如(``request``, ``response``, ``session``, ``cache``)，类(helper, validator, DAL API)和函数(``T`` 和``redirect``)。

这些对象定义在以下核心文件中:
``
web2py.py
gluon/__init__.py    gluon/highlight.py   gluon/restricted.py  gluon/streamer.py
gluon/admin.py       gluon/html.py        gluon/rewrite.py     gluon/template.py
gluon/cache.py       gluon/http.py        gluon/rocket.py      gluon/storage.py
gluon/cfs.py         gluon/import_all.py  gluon/sanitizer.py   gluon/tools.py
gluon/compileapp.py  gluon/languages.py   gluon/serializers.py gluon/utils.py
gluon/contenttype.py gluon/main.py        gluon/settings.py    gluon/validators.py
gluon/dal.py         gluon/myregex.py     gluon/shell.py       gluon/widget.py
gluon/decoder.py     gluon/newcron.py     gluon/sql.py         gluon/winservice.py
gluon/fileutils.py   gluon/portalocker.py gluon/sqlhtml.py     gluon/xmlrpc.py
gluon/globals.py     gluon/reserved_sql_keywords.py
``:code

------
注意，这些模块中有很多，特别是 ``dal`` (数据库抽象层)、``template``(模板语言)、``rocket``(web服务器)和
``html``(帮助对象)没有依赖关系，可以在web2py之外使用。
-----

与web2py一起发布的tar gzip构建应用程序是:
``
welcome.w2p
``:code

它在安装时被创建,在升级时被覆盖。

-------
第一次启动web2py时，会创建两个新文件夹:deposit和applications。deposit文件夹用作安装和卸载应用程序的临时存储。

第一次启动web2py和升级之后，"welcome"应用程序被压缩成"welcome.w2p"文件将作为基本构建应用程序来使用。
-------

当web2py升级时，它附带一个名为"NEWINSTALL"的文件。如果web2py找到这个文件，它就知道执行了升级，因此它会删除这个文件并创建一个新的"welcome.w2p"。

当前的web2py版本存储在"VERSION"字段中，它遵循标准的语义版本标记，其中构建id是构建时间戳。

web2py 的单元测试是在
``
gluon/tests/
``:code

有与各种 web 服务器连接的处理程序:
``
cgihandler.py       # discouraged
gaehandler.py       # for Google App Engine
fcgihandler.py      # for FastCGI
wsgihandler.py      # for WSGI
isapiwsgihandler.py # for IIS
modpythonhandler.py # deprecated
``:code

"fcgihandler" 调用由 Allan Saddi 开发的 "gluon/contrib/gateways/fcgi.py")和

``
anyserver.py
``

这是一个与许多不同的web服务器交互的脚本，在第13章中描述。

在"examples"目录中有三个示例文件:
``
options_std.py
routes.parametric.example.py
routes.patterns.example.py
``:code

它们都要复制到根目录(其中有web2py.py或web2py.exe)并根据您自己的喜好编辑。
前者是一个可选的配置文件,可以通过 ``-L`` 选项传递给 web2py.py。第二个示例是URL映射文件。它在重命名为"routes.py"时自动加载。第三个是一个 URL 映射的替代语法,也可以重命名(或复制到)"routes.py"。

文件
``
app.example.yaml
queue.example.yaml
``:code

示例配置文件用于在 Google App Engine 上部署的。您可以在Deployment Recipes部署章节和Google Documentation页面阅读更多关于它们的内容。

还有附加的库,通常由第三方开发:

Mark Pilgrim 开发的读取 RSS 和 Atom feeds 的 **feedparser**``feedparser``:cite  :
``
gluon/contrib/__init__.py
gluon/contrib/feedparser.py
``:code

Trent Mick 开发的用于 wiki 标记的 **markdown2**``markdown2``:cite :
``
gluon/contrib/markdown/__init__.py
gluon/contrib/markdown/markdown2.py
``:code

**markmin**  标记:
``
gluon/contrib/markmin
``:code
(参见 [[MARKMIN语法 ../05#markmin_syntax]]更多)

Mariano Reingart 创建的生成 PDF 文档的 **fpdf** :
``
gluon/contrib/fpdf
``
本书中没有对此介绍,对它的介绍在如下位置:
``
http://code.google.com/p/pyfpdf/
``

**pysimplesoap** 是由 Mariano Reingart 创建的一个轻量级的 SOAP 服务器实现:

``
gluon/contrib/pysimplesoap/
``:code

**simplejsonrpc** 是一个轻量级JSON-RPC客户端，也是由Mariano Reingart创建的: ``jsonrpc``:inxx

``
gluon/contrib/simplejsonrpc.py
``

Evan Martin 开发的 **memcache**``memcache``:cite  Python API:
``
gluon/contrib/memcache/__init__.py
gluon/contrib/memcache/memcache.py
``

**redis_cache** 是一个在``redis``:inxx数据库中存储缓存的模块:
``
gluon/contrib/redis_cache.py
``

**gql**是到 Google App Engine 的一个 DAL 端口:
``
gluon/contrib/gql.py
``:code

**memdb**是在 memcache 上的一个 DAL 端口:
``
gluon/contrib/memdb.py
``:code

**gae_memcache** 是一 个在 Google App Engine 上使用 memcache 的 API:
``
gluon/contrib/gae_memcache.py
``:code

**pyrtf**``pyrtf``:cite用于生成 RTF 格式文件,由 Simon Cusack 开发,Grant Edwards 修订:
``
gluon/contrib/pyrtf/
``:code

Dalke Scientific Software 开发的 **PyRSS2Gen**``pyrss2gen``:cite 用于生成 RSS 订阅:
``
gluon/contrib/rss2.py
``:code

**simplejson**``simplejson``:cite 是由 Bob Ippolito 开发的用于分析和编写 JSON 对象的标准库:
``
gluon/contrib/simplejson/
``:code

**Google Wallet** ``googlewallet``:cite
提供 "pay now" 按钮,其链接谷歌作为付款处理器:
``
gluon/contrib/google_wallet.py
``:code

**Stripe.com** ``stripe``:cite 提供一个简单的 API 用于接受信用卡付款:
``
gluon/contrib/stripe.py
``:code

**AuthorizeNet** ``authorizenet``:cite 提供 API 通过 Authorize.net 网络接收信用卡付款
``
gluon/contrib/AuthorizeNet.py
``:code

**Dowcommerce** ``dowcommerce``:cite 是另一个信用卡购物车处理 API:
``
gluon/contrib/DowCommerce.py
``:code

**PaymentTech** 信用卡处理API:

``
gluon/contrib/paymentech.py
``:code

**PAM**``PAM``:cite是由 Chris AtLee 创建的身份验证的API:
``
gluon/contrib/pam.py
``:code

一个贝叶斯分类器,为了测试目的而用虚拟数据填充数据库:
``
gluon/contrib/populate.py
``:code

一个在Heroku.com : ``heroku``:inxx上运行的API文件:

``
gluon/contrib/heroku.py
``:code

当 web2py 作为服务运行时,允许与 Windows 任务栏交互的一个文件:
``
gluon/contrib/taskbar_widget.py
``:code

可选的 **login_methods** 和  login_forms  被用于身份认证:
``
gluon/contrib/login_methods/__init__.py
gluon/contrib/login_methods/basic_auth.py
gluon/contrib/login_methods/browserid_account.py
gluon/contrib/login_methods/cas_auth.py
gluon/contrib/login_methods/dropbox_account.py
gluon/contrib/login_methods/email_auth.py
gluon/contrib/login_methods/extended_login_form.py
gluon/contrib/login_methods/gae_google_account.py
gluon/contrib/login_methods/ldap_auth.py
gluon/contrib/login_methods/linkedin_account.py
gluon/contrib/login_methods/loginza.py
gluon/contrib/login_methods/oauth10a_account.py
gluon/contrib/login_methods/oauth20_account.py
gluon/contrib/login_methods/oneall_account.py
gluon/contrib/login_methods/openid_auth.py
gluon/contrib/login_methods/pam_auth.py
gluon/contrib/login_methods/rpx_account.py
gluon/contrib/login_methods/x509_auth.py
``:code

web2py 还包括一个含有如下有用脚本的文件夹
``
scripts/setup-web2py-fedora.sh
scripts/setup-web2py-ubuntu.sh
scripts/setup-web2py-nginx-uwsgi-ubuntu.sh
scripts/setup-web2py-heroku.sh
scripts/update-web2py.sh
scripts/make_min_web2py.py
...
scripts/sessions2trash.py
scripts/sync_languages.py
scripts/tickets2db.py
scripts/tickets2email.py
...
scripts/extract_mysql_models.py
scripts/extract_pgsql_models.py
...
scripts/access.wsgi
scripts/cpdb.py
``:code

``setup-web2py-*`` 特别有用，因为它们尝试从头开始完整安装和设置web2py生产环境。
其中一些在第 14 章中讨论,它们里面都包含一个文档注释解释说明用途和用法。

最后,web2py 包含建立二进制发行版需要的文件。
``
Makefile
setup_exe.py
setup_app.py
``:code

**py2exe** 和 **py2app** 分别有设置脚本,只有建立 web2py 的二进制发行版时才需要它们,你应该从来不需要运行它们。

web2py应用程序包含其它文件，特别是第三方JavaScript库，如jQuery、calendar和Codemirror。它们的作者在文件中得到承认。

### 应用程序

web2py中开发的应用程序由以下部分组成:
- **models** **模型**描述数据库表的数据表示和表之间的关系。
- **controllers** **控制器**描述应用逻辑和工作流程。
- **views** **视图**描述了如何使用HTML和JavaScript向用户显示数据。
- **languages** **语言**描述如何将应用中的字符串翻译成各种受支持的语言。
- **static files** **静态文件**不需要处理(例如图片，CSS样式表等)。
- **ABOUT** 和 **README** 文件是不言自明的。
- **errors** **错误**存储应用程序生成的错误报告。
- **sessions** **会话**存储有关每个特定用户的信息。
- **databases** **数据库**存储SQLite数据库和其他表信息。
- **cache** **缓存**存储缓存的应用程序项。
- **modules** **模块**是其他可选的Python模块。
- **private** **私有**文件由控制器访问，而不是由开发者直接访问。
- **uploads** **上传**文件由模型访问，而不是由开发者直接访问(例如，应用程序用户上传的文件)。
- **tests** **tests**是存储测试脚本、fixture和mock的目录。

模型、视图、控制器、语言和静态文件的访问是通过 web 管理[design]界面,ABOUT、README 和 errors 也可以通过相应的菜单项经由管理界面访问,Sessions、 cache、modules 和 private 文件可以被应用程序访问的,但不能通过管理界面访问。

所有内容都整齐地组织在一个清晰的目录结构中,每个已安装的 web2py 应用都复制该结构,虽然用户永远不需要直接访问文件系统:

``about``:inxx ``license``:inxx ``cache``:inxx ``controllers``:inxx ``databases``:inxx ``errors``:inxx ``languages``:inxx ``models``:inxx ``modules``:inxx ``private``:inxx ``session``:inxx ``static``:inxx ``tests``:inxx ``uploads``:inxx ``views``:inxx ``__init__.py``:inxx
``
__init__.py  ABOUT        LICENSE    models    views
controllers  modules      private    tests     cron
cache        errors       upload     sessions  static
``:code

"__init__.py"是一个空文件，为了允许Python(和web2py)导入 ``modules`` 目录中的模块，它是必需的。

注意，**admin**应用程序只是为服务器文件系统上的web2py应用程序提供了一个web接口。web2py应用程序也可以通过命令行或文本编辑器/IDE创建和开发;您不必使用浏览器**admin**接口。通过复制上面的目录结构，可以手动创建新的应用程序，例如"applications/newapp/"(或者简单的将 welcome.w2p 文件解压到新应用程序目录)。应用程序文件也可以从命令行创建和编辑，而不必使用web **admin**接口界面。

### API

在已被我们导入以下对象的环境中执行模型、控制器和视图:

**全局对象:** ``request``:inxx ``response``:inxx ``session``:inxx ``cache``:inxx

``
request, response, session, cache
``:code

**国际化:** ``T``:inxx ``internationalization``:inxx

``
T
``:code

**导航:** ``redirect``:inxx ``HTTP``:inxx

``
redirect, HTTP
``:code


**导航:** ``helpers``:inxx

``
XML, URL, BEAUTIFY

A, B, BODY, BR, CENTER, CODE, COL, COLGROUP,
DIV, EM, EMBED, FIELDSET, FORM, H1, H2, H3, H4, H5, H6,
HEAD, HR, HTML, I, IFRAME, IMG, INPUT, LABEL, LEGEND,
LI, LINK, OL, UL, META, OBJECT, OPTION, P, PRE,
SCRIPT, OPTGROUP, SELECT, SPAN, STYLE,
TABLE, TAG, TD, TEXTAREA, TH, THEAD, TBODY, TFOOT,
TITLE, TR, TT, URL, XHTML, xmlescape, embed64

CAT, MARKMIN, MENU, ON
``:code

**表单和表**

``
SQLFORM (SQLFORM.factory, SQLFORM.grid, SQLFORM.smartgrid)
``

**验证器:** ``validators``:inxx

``
CLEANUP, CRYPT, IS_ALPHANUMERIC, IS_DATE_IN_RANGE, IS_DATE,
IS_DATETIME_IN_RANGE, IS_DATETIME, IS_DECIMAL_IN_RANGE,
IS_EMAIL, IS_EMPTY_OR, IS_EXPR, IS_FLOAT_IN_RANGE, IS_IMAGE,
IS_IN_DB, IS_IN_SET, IS_INT_IN_RANGE, IS_IPV4, IS_LENGTH,
IS_LIST_OF, IS_LOWER, IS_MATCH, IS_EQUAL_TO, IS_NOT_EMPTY,
IS_NOT_IN_DB, IS_NULL_OR, IS_SLUG, IS_STRONG, IS_TIME,
IS_UPLOAD_FILENAME, IS_UPPER, IS_URL
``:code

**数据库:** ``DAL``:inxx

``
DAL, Field
``:code

为了向后兼容 ``SQLDB=DAL`` 和 ``SQLField=Field``,我们鼓励使用新的语法 ``DAL`` 和 ``Field``,而不是旧的语法。

其他对象和模块在库中定义，但它们不会自动导入，因为它们不常被使用。

web2py 执行环境中的核心 API 实体包括 ``request``、  ``response``、 ``session``、``cache``、URL、 ``HTTP``、``redirect`` 和 ``T``,并在下面讨论。

在 "gluon/tools.py" 中定义了一些对象和函数，包括**Auth**、**Crud**和**Service**，需要用的时候导入它们:
``
from gluon.tools import Auth, Crud, Service
``:code
它们在搭建应用程序中的``db.py``中导入。

### 从Python模块访问API

您的模型或控制器可以导入python模块。这些通常是python文件，存储在应用程序的modules目录中。它们可能需要使用一些web2py API。方法是通过导入它们:

``
from gluon import *
``

实际上，任何Python模块，即使不是由web2py应用程序导入，只要web2py位于 ``sys.path``中，就可以导入web2py API。

[[current_object]]
#### 使用当前对象与modules共享全局作用域
但有一点需要注意。Web2py 中定义了一些全局对象(请求 request、 响应 response、会话 session、缓存 cache、 T),当一个 HTTP 请求存在(或伪造)时,其才能存在。因此,只有当它们被应用调用时模块才可以访问它们,出于这个原因,它们被放置到一个叫做 ``current``的容器中,这是一个线程局部对象。这里有一个例子。

创建一个模块 "/myapp/modules/mytest.py" ,其中包含:
``
from gluon import *
def ip(): return current.request.client
``
现在你从 "myapp" 的控制器中可以
``
import mytest
def index():
    return "Your ip is " + mytest.ip()
``

注意以下几点:

- ``import mytest`` 首先在当前应用的modules文件夹中寻找模块,之后在 ``sys.path``列出的文件夹中寻找 。 因此,应用级模块总是优先于 Python 模块,这允许不同应用附带它们不同版本的模块,而不会发生冲突。

- 不同的用户可以同时调用相同的 ``index`` 动作,调用模块中的函数,而且不会有任何冲突,因为 ``current.request`` 是处在不同线程中的不同对象,请慎重仔细,不要在模块的函数或类(即顶层)之外访问 ``current.request`` 。

- ``import mytest`` 是从 ``applications.appname.modules`` 导入 mytest 的快捷方式,使用较长的语法,可以从其它应用导入模块。

为了与普通 Python 行为的一致性,默认情况下,进行更改时 web2py 不会重新加载模块。然而,这是可以改变的,要开启自动重载模块功能,如下使用 ``track_changes`` 函数(通常在一个模型文件中,在任何导入之前):

``
from gluon.custom_import import track_changes; track_changes(True)
``:code

从现在开始，每次导入模块时，导入器都会检查Python源文件(.py)是否更改。如果已经更改，模块将被重新加载。

------
不要在modules本身中调用track_changes。
------

跟踪更改只跟踪存储在应用程序中modules的更改。
导入``current`` 的模块可以访问:
- ``current.request``
- ``current.response``
- ``current.session``
- ``current.cache``
- ``current.T``
以及应用程序选择在current存储任何其他变量。例如，一个模型可以做到

``
auth = Auth(db)
from gluon import current
current.auth = auth
current.db = db #不需要，但是有用
``

现在所有导入的模块都可以访问 ``current.auth``。

``current``和``import``建立了一个强大的机制，为您的应用程序构建可扩展和可重用的模块。

#### 警告!在模块的全局作用域中不使用当前对象
小心!给定 ``from gluon import current``，使用``current.request``和任何其他线程本地对象是正确的，但不应该将它们分配给模块中的全局变量，比如
``
request = current.request # WRONG! DANGER!
``
也不能把它分配给类属性
``
class MyClass:
    request = current.request # WRONG! DANGER!
``
这是因为线程本地对象必须在运行时提取,而全局变量只在模型第一次导入时定义一次。

相反，在函数内部赋值。

``
import * from gluon
...
def a_module_function():
    db = current.db  # 假设你分配了 current.db = db 在db.py模型中
   ...
``:code

另一个警告与缓存有关。不能使用``cache`` 对象来修饰模块中的函数，这是因为它的行为与预期不符。为了在模块中缓存一个函数``f`` ，您必须使用``lazy_cache``:

``
from gluon.cache import lazy_cache

@lazy_cache('key', time_expire=60, cache_model='ram')
def f(a, b, c): ....
``:code

注意，key是用户定义的，但必须与函数唯一关联。如果省略web2py将自动确定一个键。

### ``request``请求对象
``request``:inxx ``Storage``:inxx ``request.cookies``:inxx ``user_agent``:inxx

``request`` 对象是一个无处不在的被称为 ``gluon.storage.Storage``的 web2py 类的实例,Storage 扩展 Python 的 ``dict`` 类,它基本上是一本字典,但项目值也可以作为属性访问:
``
request.vars
``:code

等同于:
``
request['vars']
``:code

与字典不同，如果一个属性(或键)不存在，它不会引发异常。相反，它返回 ``None``。

-----
创建自己的Storage(存储)对象有时很有用。你可以这样做:
``
from gluon.storage import Storage
my_storage = Storage()  # 空storage对象
my_other_storage = Storage(dict(a=1, b=2))  # 将字典转换为Storage
``:code
-----

``request`` 具有以下项/属性，其中一些也是 ``Storage`` 类的一个实例:
- ``request.cookies``: ``Cookie.SimpleCookie()``对象包含 HTTP 请求传递的 cookie,它就像一个cookie 字典,每个 cookie 就是一个 Morsel 对象 ``morsel``:cite。
- ``request.env``: ``Storage``对象包含传递到控制器的环境变量,包括来自 HTTP 请求的 HTTP 标头变量和 WSGI 参数,便于记忆 ,环境变量都转换成小写,点转换成下划线。
- ``request.application``: 请求的应用程序的名称。
- ``request.controller``: 请求的控制器名称。
- ``request.function``: 请求的函数名称。
- ``request.extension``: 请求的动作扩展。默认是"html",如果控制器函数返回一个字典且没有指定视图,这用来确定呈现字典的视图文件的扩展名(从``request.env.path_info``解析)。
- ``request.folder``: 应用程序目录。例如，如果应用程序是 "welcome"，``request.folder``被设置为绝对路径"/path/to/welcome"。在程序中，应该始终使用这个变量和 ``os.path.join`` 函数来构建您需要访问的文件的路径。虽然web2py总是使用绝对路径，但最好不要显式地更改当前工作文件夹(无论它是什么)，因为这不是线程安全的实践。
- ``request.now``: 一个 ``datetime.datetime`` 对象存储当前请求的日期时间。
- ``request.utcnow``: 一个``datetime.datetime``对象存储当前请求的 UTC 日期时间。
- ``request.args``: 控制器函数名称之后的 URL 路径组件列表,等同于``request.env.path_info.split('/')[3:]``
- ``request.vars``: 一个``gluon.storage.Storage``对象，该对象包含所有请求参数。
- ``request.get_vars``: 一个``gluon.storage.Storage``对象仅包含传递给查询字符串的参数（一个请求``/a/c/f?var1=1&var2=2``将以处理成``{var1: "1", var2: "2"}``）
- ``request.post_vars``: 一个``gluon.storage.Storage``对象，仅包含传递到请求体中的参数(通常在POST、PUT、DELETE请求中)。
- ``request.client``: 当客户端的 ip 地址被确定,如果存在的话,由``request.env.http_x_forwarded_for``确定或否则的话由``request.env.remote_addr``确定。虽然这是有用的,但是不应该信任它,因为``http_x_forwarded_for``可以被欺骗。
- ``request.is_local``: 客户端是 localhost 为``True``,否则为``False``,如果代理支持``http_x_forwarded_for``,则应该在代理后工作。
- ``request.is_https``: 如果请求使用 HTTPS 协议,则为``True``,否则为``False``。
- ``request.body``: 一个只读文件流,它包含HTTP请求的主体,这将被自动解析得到``request.post_vars``然后重发,它可以用``request.body.read()``来读取。
- ``request.ajax`` 如果通过 Ajax 请求调用函数,则为``True``。
- ``request.cid`` 是生成Ajax请求(如果有的话)的组件的 ``id`` 。您可以在第12章中阅读有关组件的更多信息。
- ``request.requires_https()`` 如果请求不是通过HTTPS发送的，则阻止代码执行，并通过HTTPS将访问者重定向到当前页面。
- ``request.restful`` 这是一个非常有用的新装饰器，可以通过分离GET/POST/PUT/DELETE请求来改变web2py动作的默认行为。它将在第10章中详细讨论。
- ``request.user_agent()`` 从客户端解析user_agent字段并以字典的形式返回信息。检测移动设备是很有用的。它使用罗斯人创建的"gluon/contrib/user_agent_parser.py"。要知道它的功能，请尝试在视图中嵌入以下代码:
``
{{=BEAUTIFY(request.user_agent())}}
``:code

- ``request.global_settings`` ``request.global_settings``:inxx包含web2py系统范围的设置。它们是自动设置的，您不应该更改它们。例如 ``request.global_settings.gluon_parent``包含到web2py文件夹的完整路径，``request.global_settings.is_pypy``确定web2py是否在PyPy上运行。

- ``request.wsgi`` 是一个允许您从内部操作调用第三方wsgi应用程序的钩子hook

后者包括:
- ``request.wsgi.environ``
- ``request.wsgi.start_response``
- ``request.wsgi.middleware``
它们的用法在本章最后讨论。

例如，下面对一个典型系统的调用:

``
http://127.0.0.1:8000/examples/default/status/x/y/z?p=1&q=2
``:code

产生下面的request请求对象:
``request``:inxx ``env``:inxx

----------
**variable** | **value**
``request.application`` | ``examples``
``request.controller`` | ``default``
``request.function`` | ``status``
``request.extension`` | ``html``
``request.view`` | ``status``
``request.folder`` | ``applications/examples/``
``request.args`` | ``['x', 'y', 'z']``
``request.vars`` | ``<Storage {'p': 1, 'q': 2}>``
``request.get_vars`` | ``<Storage {'p': 1, 'q': 2}>``
``request.post_vars`` | ``<Storage {}>``
``request.is_local`` | ``False``
``request.is_https`` | ``False``
``request.ajax`` | ``False``
``request.cid`` | ``None``
``request.wsgi`` | ``<hook>``
``request.env.content_length`` | ``0``
``request.env.content_type`` | ````
``request.env.http_accept`` | ``text/xml,text/html;``
``request.env.http_accept_encoding`` | ``gzip, deflate``
``request.env.http_accept_language`` | ``en``
``request.env.http_cookie`` | ``session_id_examples=127.0.0.1.119725``
``request.env.http_host`` | ``127.0.0.1:8000``
``request.env.http_referer`` | ``http://web2py.com/``
``request.env.http_user_agent`` | ``Mozilla/5.0``
``request.env.path_info`` | ``/examples/simple_examples/status``
``request.env.query_string`` | ``remote_addr:127.0.0.1``
``request.env.request_method`` | ``GET``
``request.env.script_name`` | ````
``request.env.server_name`` | ``127.0.0.1``
``request.env.server_port`` | ``8000``
``request.env.server_protocol`` | ``HTTP/1.1``
``request.env.server_software`` | ``Rocket 1.2.6``
``request.env.web2py_path`` | ``/Users/mdipierro/web2py``
``request.env.web2py_version`` | ``Version 2.4.1``
``request.env.wsgi_errors`` | ``<open file, mode 'w' at >``
``request.env.wsgi_input`` | ````
``request.env.wsgi_url_scheme`` | ``http``
--------

实际上定义了哪些环境变量取决于web服务器。这里我们假设是内置的Rocket wsgi服务器。在使用Apache web服务器时，变量集没有太大的不同。

``request.env.http_*`` 变量从请求 HTTP 报头解析。

``request.env.web2py_*`` 变量不是从web服务器环境中解析的，而是由web2py创建的，以防您的应用程序需要了解web2py的位置和版本，以及它是否在谷歌应用引擎上运行(因为可能需要进行特定的优化)。

还要注意``request.env.wsgi_*``变量。它们是特定于wsgi适配器的。

### ``response``响应对象
``response``:inxx
``response.body``:inxx
``response.cookies``:inxx
``response.download``:inxx
``response.files``:inxx
``response.flash``:inxx
``response.headers``:inxx
``response.meta``:inxx
``response.menu``:inxx
``response.postprocessing``:inxx
``response.render``:inxx
``response.static_version``:inxx
``response.status``:inxx
``response.stream``:inxx
``response.subtitle``:inxx
``response.title``:inxx
``response.toolbar``:inxx
``response.view``:inxx
``response.delimiters``:inxx
``response.js``:inxx
``response.write``:inxx
``response.include_files``:inxx
``response.include_meta``:inxx
``response.optimize_css``:inxx
``response.optimize_js``:inxx
``response._caller``:inxx
``response.models_to_run``:inxx

``response`` 是 ``Storage`` 类的另一个实例。内容如下:

- ``response.body``: 一个 ``StringIO``对象,web2py 向其中写入输出页面的主体,切勿更改此变量。
- ``response.cookies``: 类似于``request.cookies``,但后者包含从客户端向服务器发送cookie,前者包含由服务器发送到客户端的 cookie,会话 cookie 自动处理。
- ``response.download(request, db)``: 是一种方法,该方法用于实现控制器功能,其功能允许下载已上传文件, ``response.download`` 期望在``request.args``中的最后一个参数``arg``是编码文件名(即,upload 上传时间产生的并存储在 upload 字段的文件名),它从编码文件名中提取上传字段名、表名以及原始文件名, ``response.download``有两个可选参数: ``chunk_size``  以字节为单位设置分块数据流的大小(默认为 64k),  ``attachments``  确定下载的文件是否应被视为附件(默认为 True)。注意,``response.download`` 是专门用于与 ``db``上传字段相关的下载文件,对于其它类型的文件下载和流媒体,使用 ``response.stream``(见下文)。另外,需要注意,没有必要使用``response.download`` 访问上传到/static 文件夹的文件——静态文件(通常应该)可以通过 URL(例如,/app/static/files/myfile.pdf)直接被访问。
- ``response.files``: 页面所需的``.css``、``.js``、``.coffee``和  ``.less``文件的列表,它们将通过包含的"web2py_ajax.html"被自动链接在标准"layout.html"的顶部。要包含一个新的CSS、JS、COFFEE或LESS文件，只需将它附加到这个列表中。它将处理重复。顺序很重要。
- ``response.include_files()`` 生成 html 头标签来包含所有``response.files``(用在"views/web2py_ajax.html"中)。
- ``response.flash``: 可选参数，可包含在视图中。通常用于通知用户发生的事情。
- ``response.headers``: 一个 HTTP响应头的``dict``。Web2py默认设置了一些头信息，包括"Content-Length"、"Content-Type"和"X-Powered-By"(设置为Web2py)。Web2py还设置了"Cache-Control"、"Expires"和"Pragma"头文件，以防止客户端缓存，只有静态文件请求除外。可以覆盖或删除web2py的标头，可以添加新的标头(例如，``response.headers['Cache-Control'] = 'private'``)。您可以通过从响应中删除其键来删除头信息。``del response.headers['Custom-Header']``，然而web2py的默认header会在返回响应之前被重新添加。要避免这种行为，只需将标头值设置为None，例如删除默认的Content-Type标头``response.headers['Content-Type'] = None``
- ``response.menu``: 可选参数,可以包含在视图中,通常用来向视图传递一个导航菜单栏,可以被 MENU 帮助对象呈现。
- ``response.meta``: 一个 storage 对象(类似一个字典)其中包含可选  ``<meta>`` 元信息如``response.meta.author``、``.description`` 和/或``.keywords``,每个 meta 元变量的内容自动放置在适当的``META`` 标签中,通过 "views/web2py_ajax.html" 中的代码实现,它默认包含在"views/layout.html" 中。
- ``response.include_meta()`` 生成一个字符串,其中包含所有序列化的``response.meta`` 标头(用在 "views/web2py_ajax.html"中)。
- ``response.postprocessing``: 这是一个函数列表，默认为空。这些函数用于在一个动作的输出处过滤响应对象，然后由视图呈现输出。它可以用来实现对其他模板语言的支持。
- ``response.render(view, vars)``: 一种用于控制器内显式调用视图的方法,``view`` 是一个可选的参数,它是视图文件的名称,``vars`` 是一个传递给视图的命名值的字典。
- ``response.session_file``: 包含会话的文件流。
- ``response.session_file_name``: 将保存会话的文件的名称。
- ``response.session_id``: 当前会话的id,它被自动确定。切勿更改此变量。
- ``response.session_id_name``: 此应用会话 cookie 的名称。切勿更改此变量。
- ``response.static_version``: 静态资源管理的版本号。
- ``response.status``: 传递给响应的 HTTP 状态代码整数,默认是 200(OK)。
- ``response.stream(file, chunk_size, request=request, attachment=False, filename=None)``:当控制器返回它时，web2py将文件内容以``chunk_size``大小的块流传输文件内容返回给客户端。使用HTTP报头中的块时，需要使用``request``参数。``file`` 应该是一个文件路径(为了向后兼容，它也可以是一个打开的文件对象，但不建议这样做)。如上所述，``response.download``应该用于检索通过上传字段存储的文件。``response.stream``可以用于其他情况，如返回一个临时文件或由控制器创建的StringIO对象。如果``attachment``为True,Content-Disposition标头将设置为"attachment"，如果还提供``filename``，它也将被添加到Content-Disposition标头中(但仅当``attachment``为True)。如果没有包含在``response.headers``中，下面的响应标头将被自动设置:Content-Type、Content-Length、Cache-Control、Pragma和Last-Modified(后三种被设置为允许文件的浏览器缓存)。要覆盖这些自动标头设置，只需在``response.headers``中设置它们，在调用``response.stream``之前。
- ``response.subtitle``: 可选的参数,该参数可以被包括在视图中,它应包含页面副标题。
- ``response.title``: 可选的参数,该参数可以被包括在视图中,它应包含页面标题并且应该由标头中的HTML标题TAG标签呈现。
- ``response.toolbar``: 允许你为调试目的在页面中嵌入工具栏的函数``{{=response.toolbar()}}``。工具栏显示每个查询的请求、响应、会话变量和数据库访问时间。
- ``response._vars``: 仅能在视图中访问此变量,而不能在动作中,它包含由动作返回给视图的值。
- ``response._caller``: 这是一个封装所有动作调用的函数。它默认为identity函数，但可以对其进行修改，以捕获特殊类型的异常以执行额外的日志记录;
  ``
  response._caller = lambda f: f()
  ``
- ``response.optimize_css``: 如果可以设置为"concat,minify,inline"来连接、缩小和内联 web2py 包含的 CSS 文件。
- ``response.optimize_js``: 如果可以设置为"concat,minify,inline"来连接、缩小和内联web2py 包含的JavaScript文件。
- ``response.view``: 呈现页面的视图模板的名称。默认设置为
  ``
  "%s/%s.%s" % (request.controller, request.function, request.extension)
  ``:code
  或者,如果上述文件不能定位,设置为
  ``
  "generic.%s" % (request.extension)
  ``:code
  更改此变量的值以修改与特定动作联的视图文件。

- ``response.delimiters`` 默认为``('{{','}}')``。它允许您更改嵌入在视图中的代码的分隔符。
- ``response.xmlrpc(request, methods)``: 当控制器返回它时，该函数通过XML-RPC``xmlrpc``:cite公开方法。由于有更好的机制将在第10章中描述，所以不建议使用此函数。
- ``response.write(text)``: 将文本写入输出页面正文的方法
- ``response.js`` 可以包含Javascript代码。此代码将在web2py组件接收到响应时执行，在第12章中讨论。
- ``response.models_to_run`` [[response_models_to_run]] 包含一个选择运行什么模型的regex正则表达式列表。
-- 默认情况下，当请求``/a/c/f``时，会自动将其设置为加载/a/models/*.py、/a/models/c/*.py和/a/models/c/f/*.py文件。您可以设置，例如，``response.models_to_run = ['myfolder/']``，以强制只在应用程序的``models/myfolder``子文件夹中执行模型。
-- 注: ``response.models_to_run``是regex正则表达式列表，而不是文件路径列表。正则表达式是相对于模型/文件夹的，因此将执行具有匹配其中一个正则表达式的相对文件路径的任何模型文件。还要注意，这不会影响已经评估过的任何模型，因为它们是按字母排序顺序更早的。也就是说，如果控制器orange的条件模型是orange/orange_model.py，并且它将正则表达式设置为[.*]，则该更改不会影响先前拒绝加载的任何模型，例如apple/apple_model.py模型；它匹配新的正则表达式，但是在orange/orange_model.py更改正则表达式之前对其进行评估并拒绝了。
-- 这意味着，如果您想使用models_to_run在控制器之间共享条件模型，请将模型放在最后排序的子目录中，例如zzz，然后使用regex 'zzz'。
.

因为``response``是``gluon.storage.Storage``对象，它可以用来存储您可能想要传递给视图的其他属性。虽然没有技术限制，但我们的建议是只存储所有页面在整体布局中呈现的变量("layout.html")。

无论如何,我们强烈建议坚持如下列出的变量:
``
response.title
response.subtitle
response.flash
response.menu
response.meta.author
response.meta.description
response.meta.keywords
response.meta.*
``:code

因为这会让您用其它布局文件替换 web2py 附带的标准"layout.html"文件变得更容易,它们使用相同变量集合。

老版本的 web2py 使用``response.author``而不是``response.meta.author``,其它 meta 属性也是相似的。

### ``session``会话对象
``session``:inxx ``session.connect``:inxx ``session.forget``:inxx ``session.secure``:inxx
``session`` 是``Storage``类的另一个实例。无论什么被存储到``session``中,例如:
``
session.myvariable = "hello"
``:code

可以在稍后的时间被检索:
``
a = session.myvariable
``:code

只要代码由相同的用户在同一个会话中执行(前提是用户没有删除会话cookie，会话也没有过期)。因为``session``是``Storage``对象，尝试访问未设置的属性/键不会引发异常;它返回``None``。

会话对象有三个重要的方法。一个是``forget``:
``
session.forget(response)
``:code

它告诉web2py不要保存会话。这应该用于那些动作经常被调用且不需要跟踪用户活动的控制器。``session.forget()``阻止会话文件被写入，不管它是否被修改过。另外，``session.forget(response)``解锁并关闭会话文件。您很少需要调用此方法，因为会话在未更改时不会保存。但是，如果页面同时发出多个Ajax请求，那么通过Ajax调用的动作调用``session.forget(response)``(假设动作不需要会话)是一个好主意。否则，每个Ajax操作都必须等待前一个动作完成(并解锁会话文件)后才能继续，这会减慢页面加载速度。请注意，在数据库中存储会话时没有锁定。

另一个方法是:

``
session.secure()
``:code

它告诉web2py将会话cookie设置为安全cookie。如果应用程序在https上运行，应该设置此设置。通过将会话cookie设置为安全的，服务器请求浏览器不要将会话cookie发送回服务器，除非通过https连接。

第三个方法是 ``connect``.
默认情况下，会话存储在文件系统中，会话cookie用于存储和检索``session.id``。使用connect方法，可以告诉web2y将会话存储在数据库或cookie中，从而消除了访问文件系统进行会话管理的需求。

例如在**数据库中存储会话**:

``
session.connect(request, response, db, masterapp=None)
``:code

其中``db``是开放式数据库连接(如同由 DAL 返回的)名称,它告诉 web2py 要在数据库而不是在文件系统中存储会话, ``session.connect``必须跟在``db=DAL(...)``之后,但在任何其它要求会话的逻辑之前,例如设置``Auth``。

web2py创建一个表:
``
db.define_table('web2py_session',
                 Field('locked', 'boolean', default=False),
                 Field('client_ip'),
                 Field('created_datetime', 'datetime', default=now),
                 Field('modified_datetime', 'datetime'),
                 Field('unique_key'),
                 Field('session_data', 'text'))
``:code

并将cPickled会话存储在``session_data``字段中。

默认情况下，选项``masterapp=None``告诉web2py尝试在运行的应用程序中检索名称为``request.application``的应用程序的现有会话。

如果您希望两个或多个应用程序共享会话，请将``masterapp``设置为主应用程序的名称。


要在**cookie中存储会话**,您可以这样做:

``
session.connect(request, response, cookie_key='yoursecret', compression_level=None)
``:code

这里的``cookie_key``是一个对称加密密钥。
``compression_level``是一个可选`zlib``加密级别。

尽管出于可伸缩性的考虑，常常推荐cookie会话，但它们的大小有限。大的会话会导致cookie损坏。

您可以通过打印``request``、``session``和``response``系统变量，随时检查应用程序的状态。一种方法是创建一个专门的动作:
``
def status():
    return dict(request=request, session=session, response=response)
``:code

在"generic.html"视图中，这是使用``{{=response.toolbar()}}``完成的。

#### 不要在会话中存储用户定义的类

在会话中存储的变量通过序列化保存在请求之中。

在执行模块代码和在定义类之前检索会话。因此，用户定义的类不能是pickled。

模块中定义的类也是一个灰色区域，不应该放在存储中。它们大部分时间都在工作，但它们可能会崩溃。这是因为，例如，如果重新启动web服务器，用户检索会话，这可能发生在导入模块之前。当web服务器启动一个新的工作进程时也是同样的问题。分布式环境中的也有相同问题。

#### 单独的会话

如果您正在文件系统上存储会话，并且您有许多会话，那么文件系统访问可能成为瓶颈。一个解决方案是:
``
session.connect(request, response, separate=True)
``:code

通过设置``separate=True``,web2py 不会在"sessions/"文件夹中存储会话,而是在"sessions/"文件夹的子文件夹中存储,并将自动创建子文件夹,具有相同前缀的会话将处在同一子文件夹中。同样,请注意,在任何可能需要该会话的逻辑之前,必须调用上述代码。

### ``cache``缓存对象
``cache``:inxx ``cache.ram``:inxx ``cache.disk``:inxx
``cache``是一个全局对象,在 web2py 执行环境中也可用。它有两个属性:
- ``cache.ram``: 主内存中的应用程序缓存。
- ``cache.disk``: 磁盘上的应用程序缓存。
``cache``是可调用的,这使得它被用来作为缓存动作和视图的装饰器decorator。

下面的例子缓存RAM中的``time.ctime()``函数:
``
def cache_in_ram():
    import time
    t = cache.ram('time', lambda: time.ctime(), time_expire=5)
    return dict(time=t, link=A('click me', _href=request.url))
``:code

``lambda: time.ctime()``的输出在 RAM 中被缓存 5s,字符串``'time'``被用作缓存关键字。

下面的例子在磁盘上缓存``time.ctime()``函数:
``
def cache_on_disk():
    import time
    t = cache.disk('time', lambda: time.ctime(), time_expire=5)
    return dict(time=t, link=A('click me', _href=request.url))
``:code

``lambda: time.ctime()``的输出被缓存在磁盘上(使用shelve模块)5秒。

注意,``cache.ram``和``cache.disk``的第 2 个参数必须是函数或可调用的对象,如果想缓存现有对象而不是函数的输出,只需通过一个lambda函数将它返回:
``
cache.ram('myobject', lambda: myobject, time_expire=60*60*24)
``:code

下一个例子缓存``time.ctime()``函数到 RAM 和磁盘:
``
def cache_in_ram_and_disk():
    import time
    t = cache.ram('time', lambda: cache.disk('time', lambda: time.ctime(), time_expire=5), time_expire=5)
    return dict(time=t, link=A('click me', _href=request.url))
``:code

``lambda: time.ctime()``的输出缓存在磁盘上(使用shelve模块)，然后在RAM中缓存5秒。web2py首先在RAM中查找，如果不在那里，则在磁盘上查找。如果缓存不在RAM或磁盘上，则执行``lambda: time.ctime()``，并更新缓存。这种技术在多进程环境中很有用。这两次不必相同。

下面的例子是在RAM中缓存控制器函数(而不是视图)的输出:

``cache controller``:inxx
``
@cache(request.env.path_info, time_expire=5, cache_model=cache.ram)
def cache_controller_in_ram():
    import time
    t = time.ctime()
    return dict(time=t, link=A('click me', _href=request.url))
``:code

``cache_controller_in_ram``返回的字典在RAM中缓存5秒。请注意，如果不首先序列化，数据库选择的结果就不能缓存。更好的方法是使用``select``方法的``cache``参数直接缓存数据库select。

下面的例子是在磁盘上缓存控制器函数的输出(而不是视图):
``
@cache(request.env.path_info, time_expire=5, cache_model=cache.disk)
def cache_controller_on_disk():
    import time
    t = time.ctime()
    return dict(time=t, link=A('click to reload', _href=request.url))
``:code

``cache_controller_on_disk``返回的字典在磁盘上缓存5秒。请记住，web2py不能缓存包含un-pickle对象的字典。

也可以缓存视图。诀窍是在控制器函数中呈现视图，这样控制器就返回一个字符串。通过返回``response.render(d)``完成的,其中``d``是我们打算传递给视图的字典。以下示例将控制器函数的输出缓存到RAM中(包括呈现的视图):

``cache view``:inxx
``
@cache(request.env.path_info, time_expire=5, cache_model=cache.ram)
def cache_controller_and_view():
    import time
    t = time.ctime()
    d = dict(time=t, link=A('click to reload', _href=request.url))
    return response.render(d)
``:code
``response.render(d)``以字符串的形式返回渲染后的视图，现在缓存5秒。这是最好和最快的缓存方式。
------
我们建议[[@cache.action #cache_action]] 从web2py > 2.4.6 开始
------

注意，``time_expire``用于将当前时间与请求对象最后一次保存到缓存中的时间进行比较。它不会影响将来的请求。这使得``time_expire``能够在请求对象时动态设置，而不是在保存对象时固定。例如:
``
message = cache.ram('message', lambda: 'Hello', time_expire=5)
``:code

现在，假设在上述调用之后10秒钟发出以下调用:
``
message = cache.ram('message', lambda: 'Goodbye', time_expire=20)
``:code

因为在第二次调用中``time_expire``被设置为20秒，并且从第一次保存消息以来只经过了10秒，所以将从缓存中检索值"Hello"，并且不会使用"Goodbye"更新它。第一次调用中的``time_expire``值5秒对第二次调用没有影响。

设置``time_expire=0``(或者一个负数)强制更新缓存项目(因为距上次保存所经过的时间总是>0),设置``time_expire=None``强制恢复缓存值,不管距上次保存所经过的时间(如果``time_expire``始终是``None``,缓存项目将有效地永不过期)。

您可以使用它清除一个或多个缓存变量
``cache clear``:inxx

``
cache.ram.clear(regex='...')
``:code

其中``regex``是一个正则表达式，匹配要从缓存中删除的所有键。你也可以用以下方法来清理一个项目:
``
cache.ram(key, None)
``:code

其中``key``是缓存项的键。

还可以定义其他缓存机制，比如memcache。Memcache可以通过``gluon.contrib.memcache``找到。在第14章中有更详细的讨论。

------
缓存时要小心，要记住缓存通常在应用程序级别，而不是用户级别。例如，如果需要缓存特定于用户的内容，请选择包含用户id的键。
------

------
应用程序的admin管理应用允许您查看缓存键(并清除缓存)。从管理员的数据库管理屏幕访问它。
------

[[cache_action]]
#### ``cache.action``
Web2py默认情况下假定返回的内容不会被缓存，因为这减少了页面客户端不适当缓存的缺点。

例如，当向用户显示表单或记录列表时，web页面不应该被缓存，因为其他用户可能已经在显示的表中插入了新记录。

相反，如果您要向用户显示一个内容永远不会改变的wiki页面(或者每周更改一次)，那么存储该页面是有用的，
但是告诉客户端该页面不会更改则更有用。

这是通过发送一些特定的标头来完成的:当客户机的浏览器接收到内容时，它被存储在浏览器的缓存中，不会再次被请求
你的网站。当然，对于面向公众的网站来说，这是一个**主要的**加速方式。

Web2py > 2.4.6 引入了一个新的``cache.action``装饰器decorator允许更聪明地处理这种情况。
``cache.action`` 可以使用:
- 用于设置智能缓存标头
- 相应地缓存结果
------
注:它会做一个或另一个或**两者都**使用。
------
用``@cache(request.env.path_info, time_expire=300, cache_model=cache.ram)``缓存视图的主要问题是request.env.path_info作为一个关键会导致几个问题，例如。
+ URL参数vars不被考虑
  -- 您缓存了''/app/default/index?**search=foo**''的结果:在接下来的300秒内''/app/default/index?**search=bar**''将返回完全相同的''/app/default/index?**search=foo**''
+ 用户不被考虑
  -- 用户经常访问一个页面，然后选择缓存它。
     但是，使用request.env.path_info作为键缓存''/app/default/index''的结果，所以是另一个用户
     将会看到不适合他的页面
  -- 您缓存了一个"Bill"页面，但是"Bill"从桌面访问了该页面。现在，他试图从他的手机访问它:如果你为
     移动用户准备一个不同于标准的模板，"Joe"将不会看到它
+ 语言不被考虑
  -- 当缓存页面时，如果对某些元素使用T()，页面将以固定的转换方式存储
+方法未被考虑
  -- 当缓存一个页面时，只有当它是GET操作的结果时，才应该缓存它
+ 状态代码未被考虑
  -- 当您第一次缓存页面时，出现了一些问题，您返回了一个404页面。
     你不想缓存错误^_^

不是让用户编写大量的样板代码来解决这些问题，而是创建了``cache.action``。
默认情况下，它会使用智能缓存标头让浏览器缓存结果:如果你向它传递一个缓存模型，它也会自动找出最佳的键，
因此，同一个页面的不同版本可以相应地存储和检索(例如，一个用于英语用户，一个用于西班牙语用户)

它需要几个参数，具有智能默认值：

- time_expire : 通常默认为300秒
- cache_model : 默认情况下为None。这意味着@cache.action**只会**改变默认的头信息，让客户端浏览器缓存内容
    -- 如果其它，例如，``cache.ram``，结果也将被存储在缓存中。
- prefix : 如果您想自动生成带前缀的键（稍后用于清除它，例如``cache.ram.clear(prefix*)``）
- session : 如果你想考虑session会话，默认为False
- vars : 如果你想考虑URL参数vars，默认为True
- lang : 如果你想考虑语言，默认为True
- user_agent : 如果您想考虑user agent用户代理，默认为false
- public :如果您想让所有用户访问同一个页面，默认为True
- valid_statuses : 默认为None。cache.client将仅缓存使用GET方法请求的页面，GET方法的状态代码以1、2或3开头。
  您可以传递一个状态码列表(当您希望使用这些状态缓存页面时，例如status_codes=[200]将只缓存
  产生200状态码的页面)
- quick : 默认为None，但您可以传递一个首字母列表来设置一个特定的特性::
  -- **S**ession, **V**ars, **L**ang, **U**ser_agent, **P**ublic
     例如. ``@cache.action(time_expire=300, cache_model=cache.ram, quick='SVP')`` 等价于
     ``@cache.action(time_expire=300, cache_model=cache.ram, session=True, vars=True, public=True)``

"考虑"的意思是，如果**vars**不同，您想缓存不同的页面，
所以对于''/app/default/index?**search=foo**''和''/app/default/index?**search=bar**''就不一样了
有些设置会覆盖其他设置，例如，如果您设置``session=True, public=True``，那么后者将被丢弃。
正确地使用它们吧!

[[URL]]
### ``URL``统一资源定位符
``URL``:inxx
``URL``函数是 web2py 中最重要的函数之一。它为动作和静态文件生成内部 URL 路径。

下面是一个例子:

``
URL('f')
``:code

映射到

``
/[application]/[controller]/f
``:code

注意，``URL``函数的输出取决于当前应用程序的名称、调用控制器和其他参数。web2py支持URL映射和反向URL映射。URL映射允许您重新定义外部URL的格式。如果使用``URL``函数生成所有内部URL，那么对URL映射的添加或更改将防止破坏web2py应用程序中的链接。

You can pass additional parameters to the ``URL`` function, i.e., extra terms in the URL path (args) and URL query variables (vars):
您可以向 ``URL`` 函数传递额外的参数，即， URL路径(args)和URL查询变量(vars):
``
URL('f', args=['x', 'y'], vars=dict(z='t'))
``:code

映射到

``
/[application]/[controller]/f/x/y?z=t
``:code

 ``args`` 属性会自动解析、解码，最后存储在web2py的 ``request.args`` 中。同样， ``vars`` 也被解析、解码，然后存储在``request.vars``中。
``args`` 和 ``vars`` 提供了web2py与客户端浏览器交换信息的基本机制。

如果args只包含一个元素，则不需要在列表中传递它。

你也可以使用 ``URL`` 函数来生成URL到其他控制器和其他应用程序中的动作:

``
URL('a', 'c', 'f', args=['x', 'y'], vars=dict(z='t'))
``:code

映射到

``
/a/c/f/x/y?z=t
``

还可以使用命名参数指定应用程序、控制器和函数:

``
URL(a='a', c='c', f='f')
``:code

如果应用程序名称 ''a'' 缺失，则假定当前应用程序。

``
URL('c', 'f')
``:code

如果缺少控制器名称 ''c'' ，则假定是当前的。

``
URL('f')
``:code

与其传递控制器函数的名称，还可以传递函数本身

``
URL(f)
``:code

基于上述原因，您应该始终使用``URL`` 函数为您的应用程序生成静态文件的URL。静态文件存储在应用程序的``static``静态子文件夹中(当使用admin管理界面上传时，它们会被存储在该子文件夹中)。web2py提供了一个虚拟的'static'静态控制器，其工作是从``static``静态子文件夹中检索文件，确定它们的内容类型，并将文件流传输到客户端。下面的示例生成静态文件"image.png"的URL:

``
URL('static', 'image.png')
``:code

映射到

``
/[application]/static/image.png
``:code

如果静态文件位于``static``静态文件夹中的子文件夹中，则可以将子文件夹作为文件名的一部分。例如，生成:

``
/[application]/static/images/icons/arrow.png
``

每个人都应该使用:

``
URL('static', 'images/icons/arrow.png')
``:code

你不需要编码/转义``args`` 和 ``vars`` 参数;这是自动为你做的。

默认情况下，与当前请求相对应的扩展(可以在``request.extension``中找到)被追加到函数中，除非request.extension是默认的html。这可以通过显式地包括扩展作为函数名 ``URL(f='name.ext')`` 的一部分或使用扩展参数来覆盖:
``
URL(..., extension='css')
``:code

可以显式地抑制当前扩展:
``
URL(..., extension=False)
``:code

#### 绝对url

默认情况下，``URL``生成相对URL。不过，您也可以通过指定``scheme``和``host``参数来生成绝对url(例如，在电子邮件消息中插入url时，这很有用):

``
URL(..., scheme='http', host='www.mysite.com')
``:code

您可以通过简单地将参数设置为``True``来自动包括方案和当前请求的主机。

``
URL(..., scheme=True, host=True)
``:code

``URL``函数还接受``port``端口参数，以便在必要时指定服务器端口。

#### 数字签名的url
``digitally signed URL``:inxx

在生成URL时，您可以选择对其进行数字签名。这将附加一个``_signature``GET变量，可以由服务器验证。这可以通过两种方式实现。

您可以将以下参数传递给URL函数:
- ``hmac_key``: 签署名URL的密钥(一个字符串)
- ``salt``: 一个可选的字符串，用于在签名前对数据进行salt处理
- ``hash_vars``: 来自 URL 查询字符串的变量名可选列表(即 GET 变量)要包含在签名中,也可以将它设置成``True`` ,以包含全部变量;或``False``,以不包含任何变量。

下面是一个用法的例子:

``
KEY = 'mykey'

def one():
    return dict(link=URL('two', vars=dict(a=123), hmac_key=KEY))

def two():
    if not URL.verify(request, hmac_key=KEY): raise HTTP(403)
    # 这块可以做一些事情
    return locals()
``:code

这使得动作 ``two`` 只能通过数字签名URL访问。数字签名URL如下:
``
'/welcome/default/two?a=123&_signature=4981bc70e13866bb60e52a09073560ae822224e9'
``

注意，数字签名是通过``URL.verify``函数验证。``URL.verify`` 还使用上面描述的``hmac_key``、``salt``和``hash_vars``参数，其值必须与数字签名创建时传递给 ``URL`` 函数的值匹配，以验证URL。

第二个更复杂但更常见的数字签名url与Auth一起使用。最好用一个例子来解释:

``
@auth.requires_login()
def one():
    return dict(link=URL('two', vars=dict(a=123), user_signature=True)

@auth.requires_signature()
def two():
    # 这块可以做一些事情
    return locals()
``:code

在这种情况下，``hmac_key`` 会自动生成并在会话中共享。这允许action ``two``将任何访问控制委托给action ``one``。如果该链接被生成并签名，它是有效的;否则就不是。如果该链接被其他用户窃取，该链接将无效。

总是对Ajax回调进行数字签名是很好的实践。如果你使用web2py``LOAD``函数，它也有一个``user_signature``参数，可以用于这个目的:

``
{{=LOAD('default', 'two', vars=dict(a=123), ajax=True, user_signature=True)}}
``

### ``HTTP``和重定向``redirect``
``HTTP``:inxx ``redirect``:inxx

web2py只定义了一个名为``HTTP``的新异常。这个异常可以用以下命令在模型、控制器或视图的任何地方引发:

``
raise HTTP(400, "my message")
``:code

它导致控制流从用户的代码跳到web2py，并返回HTTP响应，如下所示:
``
HTTP/1.1 400 BAD REQUEST
Date: Sat, 05 Jul 2008 19:36:22 GMT
Server: Rocket WSGI Server
Content-Type: text/html
Via: 1.1 127.0.0.1:8000
Connection: close
Transfer-Encoding: chunked

my message
``:code

``HTTP``的第一个参数是HTTP状态码。第二个参数是作为响应主体返回的字符串。附加的可选命名参数用于构建响应HTTP头。
例如:
``
raise HTTP(400, 'my message', test='hello')
``:code

生成:
``
HTTP/1.1 400 BAD REQUEST
Date: Sat, 05 Jul 2008 19:36:22 GMT
Server: Rocket WSGI Server
Content-Type: text/html
Via: 1.1 127.0.0.1:8000
Connection: close
Transfer-Encoding: chunked
test: hello

my message
``:code

If you do not want to commit the open database transaction, rollback before raising the exception.

Any exception other than ``HTTP`` causes web2py to roll back any open database transaction, log the error traceback, issue a ticket to the visitor, and return a standard error page.

This means that only ``HTTP`` can be used for cross-page control flow. Other exceptions must be caught by the application, otherwise they are ticketed by web2py.

The command:
``
redirect('http://www.web2py.com')
``:code

is simply a shortcut for:
``
raise HTTP(303,
           'You are being redirected <a href="%s">here</a>' % location,
           Location='http://www.web2py.com')
``:code

The named arguments of the ``HTTP`` initializer method are translated into HTTP header directives, in this case, the redirection target location. ``redirect`` takes an optional second argument, which is the HTTP status code for the redirection (303 by default). Change this number to 307 for a temporary redirect or to 301 for a permanent redirect.

The most common way to use redirect is to redirect to other pages in the same app and (optionally) pass parameters:

``
redirect(URL('index', args=(1, 2, 3), vars=dict(a='b')))
``:code

In chapter 12 we discuss web2py components. They make Ajax requests to web2py actions. If the called action performs a redirect, you may want the Ajax request to follow the redirect or you may want the entire page performing the Ajax request redirecting. In this latter case you can set:

``
redirect(..., client_side=True)
``:code


### Internationalization, and Pluralization with ``T``
``T``:inxx ``internationalization``:inxx

The object ``T`` is the language translator. It constitutes a single global instance of the web2py class ``gluon.language.translator``. All string constants (and only string constants) should be marked by ``T``, for example:
``
a = T("hello world")
``:code

Strings that are marked with ``T`` are identified by web2py as needing language translation and they will be translated when the code (in the model, controller, or view) is executed. If the string to be translated is not a constant but a variable, it will be added to the translation file at runtime (except on GAE) to be translated later.

The ``T`` object can also contain interpolated variables and supports multiple equivalent syntaxes:
``
a = T("hello %s", ('Tim', ))
a = T("hello %(name)s", dict(name='Tim'))
a = T("hello %s") % ('Tim', )
a = T("hello %(name)s") % dict(name='Tim')
``:code

The latter syntax is recommended because it makes translation easier.
The first string is translated according to the requested language file and the ``name`` variable is replaced independently of the language.

You can concatenate translated strings and normal strings:
``
T("blah ") + name + T(" blah")
``:code

The following code is also allowed and often preferable:

``
T("blah %(name)s blah", dict(name='Tim'))
``:code

or the alternative syntax
``
T("blah %(name)s blah") % dict(name='Tim')
``:code

In both cases the translation occurs before the variable name is substituted in the "%(name)s" slot. The following alternative should NOT BE USED:
``
T("blah %(name)s blah" % dict(name='Tim'))
``:code

because translation would occur after substitution.

#### Determining the language

The requested language is determined by the "Accept-Language" field in the HTTP header, but this selection can be overwritten programmatically by requesting a specific file, for example:
``
T.force('it-it')
``:code

which reads the "languages/it-it.py" language file. Language files can be created and edited via the administrative interface.

You can also force a per-string language:

``
T("Hello World", language="it-it")
``:code

--------------
In the case multiple languages are requested, for example "it-it, fr-ft", web2py tries to locate "it-it.py" and "fr-fr.py" translation files. If none of the requested files is present, it tries to fall back on "it.py" and "fr.py". If these files are not present it defaults to "default.py". If this is not present either, it default to no-translation. The more general rule is that web2py tries "xx-xy-yy.py", "xx-xy.py", "xx.py", "default.py" for each of the "xx-xy-yy" accepted languages trying to find the closest match to the visitor's preferences.
-------------

You can turn off translations completely via

``
T.force(None)
``:code

Normally, string translation is evaluated lazily when the view is rendered; hence, the translator ``force`` method should not be called inside a view.

It is possible to disable lazy evaluation via
``
T.lazy = False
``:code

In this way, strings are translated inmediately by the ``T`` operator based on the currently accepted or forced language.

It is also possible to disable lazy evaluation for individual strings:

``
T("Hello World", lazy=False)
``:code

A common issue is the following. The original application is in English. Suppose that there is a translation file (for example Italian, "it-it.py") and the HTTP client declares that it accepts both English (en) and Italian (it-it) in that order. The following unwanted situation occurs: web2py does not know the default is written in English (en). Therefore, it prefers translating everything into Italian (it-it) because it only found the Italian translation file. If it had not found the "it-it.py" file, it would have used the default language strings (English).

There are two solutions for this problem: create a translation language for English, which would be redundant and unnecessary, or better, tell web2py which languages should use the default language strings (the strings coded into the application). This can be done with:
``
T.set_current_languages('en', 'en-en')
``:code

It stores in  ``T.current_languages`` a list of languages that do not require translation and forces a reload of the language files.

Notice that "it" and "it-it" are different languages from the point of view of web2py. To support both of them, one would need two translation files, always lower case. The same is true for all other languages.

The currently accepted language is stored in
``
T.accepted_language
``:code

#### Translating variables

T(...) does not only translate strings but it can also translate values stored in variables:
``
>>> a = "test"
>>> print T(a)
``:code

In this case the word "test" is translated but, if not found and if the filesystem is writable, it will add it to the list of words to be translated in the language file.

Notice that this can result in lots of file IO and you may want to disable it:

``
T.is_writable = False
``:code

prevents T from dynamically updating language files.

#### Comments and multiple translations

It is possible that the same string appears in different contexts in the application and needs different translations based on context. In order to do this, one can add comments to the original string. The comments will not be rendered but will be used by web2py to determine the most appropriate translation. For example:

``
T("hello world ## first occurrence")
T("hello world ## second occurrence")
``:code

The text following the ``##``, including the double ``##``, are comments.

#### Pluralization engine

Since version 2.0, web2py includes a powerful pluralization system (PS). This means that when text marked for translation depends on a numeric variable, it may be translated differently based on the numeric value. For example in English we may render:

``
x book(s)
``

with

``
a book (x==1)
5 books (x==5)
``

English has one singular form and one plural form. The plural form is constructed by adding a "-s" or "-es" or using an exceptional form. web2py provides a way to define pluralization rules for each language, as well as exceptions to the default rules. In fact web2py already knows pluralization rules for many languages. It knows, for example, that Slovenian has one singular form and 3 plural forms (for x==2, x==3 or x==4 and x>4). These rules are encoded in "gluon/contrib/plural_rules/*.py" files and new files can be created. Explicit pluralizations for words are created by editing pluralization files using the administrative interface.

By default the PS is not activated. It is triggered by the ``symbol`` argument of the ``T`` function. For example:

``
T("You have %s %%{book}", symbols=10)
``:code

Now the PS is activated for the word "book" and for the number 10.
The result in English will be: "You have 10 books". Notice that "book" has been pluralized into "books".

The PS consists of 3 parts:
- placeholders ``%%{}`` to mark words in the ``T`` input
- rule to give a decision which word form to use ("rules/plural_rules/*.py")
- dictionary with word plural forms ("app/languages/plural-*.py")

The value of symbols can be a single variable, a list/tuple of variables, or a dictionary.

The placeholder ``%%{}`` consists of 3 parts:

``
%%{[<modifier>]<word>[<parameter>]},
``

where:

``
<modifier>::= ! | !! | !!!
<word> ::= any word or phrase in singular in lower case (!)
<parameter> ::= [index] | (key) | (number)
``

For example:

- ``%%{word}`` is equivalent to ``%%{word[0]}`` (if no modifiers are used).
- ``%%{word[index]}`` is used when symbols is a tuple. symbols[index] gives us a number used to make a decision on which word form to choose.
- ``%%{word(key)}`` is used to get the numeric parameter from symbols[key]
- ``%%{word(number)}`` allows to set a ``number`` directly (e.g.: ``%%{word(%i)}``)
- ``%%{?word?number}`` returns "word" if ``number==1``, returns the ``number`` otherwise
- ``%%{?number} or %%{??number}`` returns ``number`` if ``number!=1``, return nothing otherwise

``T("blabla %s %%{word}", symbols=var)``

``%%{word}`` by default means ``%%{word[0]}``,
where ``[0]`` is an item index in symbols tuple.

``T("blabla %s %s %%{word[1]}", (var1, var2))``
PS is used for "word" and "var2" respectively.

You can use several ``%%{}`` placeholders with one index:

``T("%%{this} %%{is} %s %%{book}", var)``

or

``T("%%{this[0]} %%{is[0]} %s %%{book[0]}", var)``

They generate:

``
var  output
------------------
 1   this is 1 book
 2   these are 2 books
 3   these are 2 books
``

Similarly you can pass a dictionary to symbols:

``
T("blabla %(var1)s %(wordcnt)s %%{word(wordcnt)}",
  dict(var1="tututu", wordcnt=20))
``

which produces

``
blabla tututu 20 words
``

You can replace "1" with any word you wish by this placeholder ``%%{?word?number}``.
For example

``T("%%{this} %%{is} %%{?a?%s} %%{book}", var)``

produces:

``
var  output
------------------
 1   this is a book
 2   these are 2 books
 3   these are 3 books
 ...
``

Inside ``%%{...}`` you can also use the following modifiers:

- ``!`` to capitalize the text (equivalent to ``string.capitalize``)
- ``!!`` to capitalize every word (equivalent to ``string.title``)
- ``!!!`` to capitalize every character (equivalent to ``string.upper``)

Notice you can use \ to escape ``!`` and ``?``.

#### Translations, pluralization, and MARKMIN

You can also use the powerful MARKMIN syntax inside translation strings by replacing

``
T("hello world")
``:code

with

``
T.M("hello world")
``

Now the string accepts MARKMIN markup as described in [[Chapter 5 ../05#markmin_syntax]]

### Cookies

``cookies``:inxx

web2py uses the Python cookies modules for handling cookies.

Cookies from the browser are in ``request.cookies`` and cookies sent by the server are in ``response.cookies``.

You can set a cookie as follows:
``
response.cookies['mycookie'] = 'somevalue'
response.cookies['mycookie']['expires'] = 24 * 3600
response.cookies['mycookie']['path'] = '/'
``:code

The second line tells the browser to keep the cookie for 24 hours. The third line tells the browser to send the cookie back to any application (URL path) at the current domain. Note, if you do not specify a path for the cookie, the browser will assume the path of the URL that was requested, so the cookie will only be returned to the server when that same URL path is requested.

The cookie can be made secure with:
``
response.cookies['mycookie']['secure'] = True
``:code

This tells the browser only to send the cookie back over HTTPS and not over HTTP.

The cookie can be retrieved with:
``
if request.cookies.has_key('mycookie'):
    value = request.cookies['mycookie'].value
``:code

Unless sessions are disabled, web2py, under the hood, sets the following cookie and uses it to handle sessions:
``
response.cookies[response.session_id_name] = response.session_id
response.cookies[response.session_id_name]['path'] = "/"
``:code

Note, if a single application includes multiple subdomains, and you want to share the session across those subdomains (e.g., sub1.yourdomain.com, sub2.yourdomain.com, etc.), you must explicitly set the domain of the session cookie as follows:
``
if not request.env.remote_addr in ['127.0.0.1', 'localhost']:
    response.cookies[response.session_id_name]['domain'] = ".yourdomain.com"
``:code

The above can be useful if, for example, you want to allow the user to remain logged in across subdomains.


### Application **init**
``init``:inxx

When you deploy web2py, you will want to set a default application, i.e., the application that starts when there is an empty path in the URL, as in:
``
http://127.0.0.1:8000
``:code

By default, when confronted with an empty path, web2py looks for an application called **init**. If there is no init application it looks for an application called **welcome**.

``default_application``:inxx
The name of the default application can be changed from **init** to another name by setting ``default_application`` in routes.py:
``
default_application = "myapp"
``:code

Note: ``default_application`` first appeared in web2py version 1.83.

Here are four ways to set the default application:
- Call your default application "init".
- Set ``default_application`` to your application's name in routes.py
- Make a symbolic link from "applications/init" to your application's folder.
- Use URL rewrite as discussed in the next section.

### URL rewrite
``url rewrite``:inxx
``routes_in``:inxx
``routes_out``:inxx

web2py has the ability to rewrite the URL path of incoming requests prior to calling the controller action (URL mapping), and conversely, web2py can rewrite the URL path generated by the ``URL`` function (reverse URL mapping). One reason to do this is for handling legacy URLs, another is to simplify paths and make them shorter.

web2py includes two distinct URL rewrite systems: an easy-to-use ''parameter-based'' system for most use cases, and a flexible ''pattern-based'' system for more complex cases. To specify the URL rewrite rules, create a new file in the "web2py" folder called ``routes.py`` (the contents of ``routes.py`` will depend on which of the two rewrite systems you choose, as described in the next two sections). The two systems cannot be mixed.

-------
Notice that if you edit routes.py, you must reload it. This can be done in two ways: by restarting the web server or by clicking on the routes reload button in admin. If there is a bug in routes, they will not reload.
-------

#### Parameter-based system

The parameter-based (parametric) router provides easy access to several "canned" URL-rewrite methods. Its capabilities include:

- Omitting default application, controller and function names from externally-visible URLs (those created by the URL() function)
- Mapping domains (and/or ports) to applications or controllers
- Embedding a language selector in the URL
- Removing a fixed prefix from incoming URLs and adding it back to outgoing URLs
- Mapping root files such as /robots.txt to an applications static directory

The parametric router also provides somewhat more flexible validation of incoming URLs.

Suppose you've written an application called ``myapp`` and wish to make it the default, so that the application name is no longer part of the URL as seen by the user. Your default controller is still ``default``, and you want to remove its name from user-visible URLs as well. Here's what you put in ``routes.py``:
``
routers = dict(
  BASE  = dict(default_application='myapp'),
)
``:code

That's it. The parametric router is smart enough to know how to do the right thing with URLs such as:
``
http://domain.com/myapp/default/myapp
``:code
or
``
http://domain.com/myapp/myapp/index
``:code
where normal shortening would be ambiguous. If you have two applications, ``myapp`` and ``myapp2``, you'll get the same effect, and additionally ``myapp2``'s default controller will be stripped from the URL whenever it's safe (which is mostly all the time).

Here is another case: suppose you want to support URL-based languages, where your URLs look like this:
``
http://myapp/en/some/path
``:code
or (rewritten)
``
http://en/some/path
``:code

Here's how:
``
routers = dict(
  BASE  = dict(default_application='myapp'),
  myapp = dict(languages=['en', 'it', 'jp'], default_language='en'),
)
``:code

Now an incoming URL like this:
``
http:/domain.com/it/some/path
``:code
will be routed to ``/myapp/some/path``, and request.uri_language will be set to 'it', so you can force the translation. You can also have language-specific static files.

``
http://domain.com/it/static/filename
``:code
will be mapped to:
``
applications/myapp/static/it/filename
``:code
if that file exists. If it doesn't, then URLs like:
``
http://domain.com/it/static/base.css
``:code
will still map to:
``
applications/myapp/static/base.css
``:code
(because there is no ``static/it/base.css``).

So you can now have language-specific static files, including images, if you need to.  Domain mapping is supported as well:
``
routers = dict(
  BASE  = dict(
      domains = {
          'domain1.com' : 'app1',
          'domain2.com' : 'app2',
      }
  ),
)
``:code
does what you'd expect.

``
routers = dict(
  BASE  = dict(
      domains = {
          'domain.com:80'  : 'app/insecure',
          'domain.com:443' : 'app/secure',
      }
  ),
)
``:code
maps ``http://domain.com`` accesses to the controller named ``insecure``, while ``HTTPS`` accesses go to the ``secure`` controller. Alternatively, you can map different ports to different apps, in the obvious way.

For further information, please consult the file [["routes.parametric.example.py" https://github.com/web2py/web2py/blob/master/examples/routes.parametric.example.py]] provided in the "examples" folder of the standard web2py distribution.

Note: The ''parameter-based'' system first appeared in web2py version 1.92.1.

#### Pattern-based system

Although the ''parameter-based'' system just described should be sufficient for most use cases, the alternative ''pattern-based'' system provides some additional flexibility for more complex cases. To use the pattern-based system, instead of defining routers as dictionaries of routing parameters, you define two lists (or tuples) of 2-tuples, ``routes_in`` and ``routes_out``. Each tuple contains two elements: the pattern to be replaced and the string that replaces it. For example:
``
routes_in = (
  ('/testme', '/examples/default/index'),
)
routes_out = (
  ('/examples/default/index', '/testme'),
)
``:code

With these routes, the URL:
``
http://127.0.0.1:8000/testme
``:code

is mapped into:
``
http://127.0.0.1:8000/examples/default/index
``:code

To the visitor, all links to
the page URL looks like ``/testme``.

The patterns have the same syntax as Python regular expressions. For example:
``
  ('.*\.php', '/init/default/index'),
``:code

maps all URLs ending in ".php" to the index page.

The second term of a rule can also be a redirection to another page:
``
  ('.*\.php', '303->http://example.com/newpage'),
``:code

Here 303 is the HTTP code for the redirect response.

Sometimes you want to get rid of the application prefix from the URLs because you plan to expose only one application. This can be achieved with:
``
routes_in = (
  ('/(?P<any>.*)', '/init/\g<any>'),
)
routes_out = (
  ('/init/(?P<any>.*)', '/\g<any>'),
)
``:code

There is also an alternative syntax that can be mixed with the regular expression notation above. It consists of using ``$name`` instead of ``(?P<name>\w+)`` or ``\g<name>``. For example:
``
routes_in = (
  ('/$c/$f', '/init/$c/$f'),
)

routes_out = (
  ('/init/$c/$f', '/$c/$f'),
)
``:code

would also eliminate the "/example" application prefix in all URLs.


Using the ``$name`` notation, you can automatically map ``routes_in`` to ``routes_out``, provided you don't use any regular expressions. For example:
``
routes_in = (
  ('/$c/$f', '/init/$c/$f'),
)

routes_out = [(x, y) for (y, x) in routes_in]
``:code

If there are multiple routes, the first to match the URL is executed. If no pattern matches, the path is left unchanged.

You can use ``$anything`` to match anything (``.*``) until the end of the line.

Here is a minimal "routes.py" for handling favicon and robots requests:

``favicon``:inxx ``robots``:inxx
``
routes_in = (
  ('/favicon.ico', '/examples/static/favicon.ico'),
  ('/robots.txt', '/examples/static/robots.txt'),
)
routes_out = ()
``:code

Here is a more complex example that exposes a single app "myapp" without unnecessary prefixes but also exposes **admin**, **appadmin** and static:

``
routes_in = (
  ('/admin/$anything', '/admin/$anything'),
  ('/static/$anything', '/myapp/static/$anything'),
  ('/appadmin/$anything', '/myapp/appadmin/$anything'),
  ('/favicon.ico', '/myapp/static/favicon.ico'),
  ('/robots.txt', '/myapp/static/robots.txt'),
)
routes_out = [(x, y) for (y, x) in routes_in[:-2]]
``:code

The general syntax for routes is more complex than the simple examples we have seen so far. Here is a more general and representative example:
``
routes_in = (
 ('140\.191\.\d+\.\d+:https?://www.web2py.com:post /(?P<any>.*)\.php',
  '/test/default/index?vars=\g<any>'),
)
``:code

It maps ``http`` or ``https`` ``POST`` requests (note lower case "post") to host ``www.web2py.com`` from a remote IP matching the regular expression
``
'140\.191\.\d+\.\d+'
``:code

requesting a page matching the regular expression
``
'/(?P<any>.*)\.php'
``:code

into
``
'/test/default/index?vars=\g<any>'
``:code

where ``\g<any>`` is replaced by the matching regular expression.

The general syntax is
``
'[remote address]:[protocol]://[host]:[method] [path]'
``:code

If the first section of the pattern (all but ``[path]``) is missing, web2py provides a default:
``
'.*?:https?://[^:/]+:[a-z]+'
``:code

The entire expression is matched as a regular expression, so "." must be escaped and any matching subexpression can be captured using ``(?P<...>...)`` using Python regex syntax. The request method (typically GET or POST) must be lower case. The URL being matched has had any ``%xx`` escapes unquoted.

This allows to reroute requests based on the client IP address or domain, based on the type of the request, on the method, and the path. It also allows web2py to map different virtual hosts into different applications. Any matched subexpression can be used to build the target URL and, eventually, passed as a GET variable.

All major web servers, such as Apache and lighttpd, also have the ability to rewrite URLs. In a production environment that may be an option instead of ``routes.py``. Whatever you decide to do we strongly suggest that you do not hardcode internal URLs in your app and use the URL function to generate them. This will make your application more portable in case routes should change.

##### Application-Specific URL rewrite
``routes_app``:inxx
When using the pattern-based system, an application can set its own routes in an application-specific routes.py file located in the applications base folder. This is enabled by configuring ``routes_app`` in the base routes.py to determine from an incoming URL the name of the application to be selected. When this happens, the application-specific routes.py is used in place of the base routes.py.

The format of ``routes_app`` is identical to ``routes_in``, except that the replacement pattern is simply the application name. If applying ``routes_app`` to the incoming URL does not result in an application name, or the resulting application-specific routes.py is not found, the base routes.py is used as usual.

Note: ``routes_app`` first appeared in web2py version 1.83.

##### Default application, controller, and function
``default_application``:inxx
``default_controller``:inxx
``default_function``:inxx

When using the pattern-based system, the name of the default application, controller, and function can be changed from **init**, **default**, and **index** respectively to another name by setting the appropriate value in routes.py:
``
default_application = "myapp"
default_controller = "admin"
default_function = "start"
``:code

Note: These items first appeared in web2py version 1.83.

#### Routes on error
``routes_onerror``:inxx

You can also use ``routes.py`` to re-route requests to special actions in case there is an error on the server. You can specify this mapping globally, for each app, for each error code, or for each app and error code. Here is an example:
``
routes_onerror = [
  ('init/400', '/init/default/login'),
  ('init/*', '/init/static/fail.html'),
  ('*/404', '/init/static/cantfind.html'),
  ('*/*', '/init/error/index')
]
``:code

For each tuple, the first string is matched against "[app name]/[error code]". If a match is found, the failed request is re-routed to the URL in the second string of the matching tuple. If the error handling URL is a not a static file, the following GET variables will be passed to the error action:
- ``code``: the HTTP status code (e.g., 404, 500)
- ``ticket``: in the form of "[app name]/[ticket number]" (or "None" if no ticket)
- ``requested_uri``: equivalent to ``request.env.request_uri``
- ``request_url``: equivalent to ``request.url``

These variables will be accessible to the error handling action via ``request.vars`` and can be used in generating the error response. In particular, it is a good idea for the error action to return the original HTTP error code instead of the default 200 (OK) status code. This can be done by setting ``response.status = request.vars.code``. It is also possible to have the error action send (or queue) an email to an administrator, including a link to the ticket in ``admin``.

Unmatched errors display a default error page. This default error page can also be customized here (see "routes.parametric.example.py" and "routes.patterns.example.py" in the "examples" folder):
``
error_message = '<html><body><h1>%s</h1></body></html>'
error_message_ticket = '''<html><body><h1>Internal error</h1>
     Ticket issued: <a href="/admin/default/ticket/%(ticket)s"
     target="_blank">%(ticket)s</a></body></html>'''
``:code

The first variable contains the error message when an invalid application or function is requested. The second variable contains the error message when a ticket is issued.

``routes_onerror`` work with both routing mechanisms.

``error_handler``:inxx
In "routes.py" you can also specify an action in charge of error handling:

``
error_handler = dict(application='error',
                     controller='default',
                     function='index')
``:code

If the ``error_handler`` is specified the action is called without user redirection and the handler action will be in charge of dealing with the error. In the event that the error-handling page itself returns an error, web2py will fall back to its old static responses.


#### Static asset management

Since version 2.1.0, web2py has the ability to manage static assets.

When an application is in development, static file can change often, therefore web2py sends static files with no cache headers. This has the side-effect of "forcing" the browser to request static files at every request. This results in low performance when loading the page.

In a "production" site, you may want to serve static files with ``cache`` headers to prevent un-necessary downloads since static files do not change.

``cache`` headers allow the browser to fetch each file only once, thus saving bandwidth and reducing loading time.

Yet there is a problem: What should the cache headers declare? When should the files expire? When the files are first served, the server cannot forecast when they will be changed.

A manual approach consists of creating subfolders for different versions of static files. For example an early version of "layout.css" can be made available at the URL "/myapp/static/css/1.2.3/layout.css". When you change the file, you create a new subfolder and you link it as "/myapp/static/css/1.2.4/layout.css".

This procedure works but it is pedantic since every time you update the css file, you must remember to move it to another folder, change the URL of the file in your layout.html and deploy.

Static asset management solves the problem by allowing the developer to declare a version for a group of static files and they will be requested again only when the version number changes. The asset version number is made part of the file url as in the previous example. The difference from the previous approach is that the version number only appears in the URL, not in the file system.


If you want to serve "/myapp/static/layout.css" with the cache headers, you just need to include the file with a modified URL that includes a version number:
``
/myapp/static/_1.2.3/layout.css
``
(notice the URL defines a version number, it does not appear anywhere else).

Notice that the URL starts with "/myapp/static/", followed by a version number composed by an underscore and 3 integers separated by a period (as described in [[SemVer http://semver.org/]]), then followed by the filename. Also notice that you do not have to create a "_1.2.3/" folder.

Every time the static file is requested with a version in the url, it will be served with "far in the future" cache headers, specifically:
``
Cache-Control : max-age=315360000
Expires: Thu, 31 Dec 2037 23:59:59 GMT
``
This means that the browser will fetch those files only once, and they will be saved "forever" in the browser's cache.

Every time the "_1.2.3/filename" is requested, web2py will remove the version part from the path and serve your file with far in the future headers so they will be cached forever. If you changed the version number in the URL, this tricks the browser into thinking it is requesting a different file, and the file is fetched again.

You can use "_1.2.3", "_0.0.0", "_999.888.888", as long as the version starts with underscore followed by three numbers separated by period.

When in development, you can use ``response.files.append(...)`` to link the static URLs of static files. In this case you can include the "_1.2.3/" part manually, or you take advantage of a new parameter of the response object: ``response.static_version``.
Just include the files the way you used to, for example
``
{{response.files.append(URL('static', 'layout.css'))}}
``
and in models set
``
response.static_version = '1.2.3'
``:code
This will rewrite automatically every "/myapp/static/layout.css" url as "/myapp/static/_1.2.3/layout.css", for every file included in ``response.files``.

Often in production you let the webserver (apache, nginx, etc.) serve the static files. You need to adjust your configuration in such a way that it will "skip" the "_1.2.3/" part.

For example, in Apache, change this:
``
AliasMatch ^/([^/]+)/static/(.*) \
   /home/www-data/web2py/applications/$1/static/$2
``
into this:
``
AliasMatch ^/([^/]+)/static/(?:_[\d]+.[\d]+.[\d]+/)?(.*) \
   /home/www-data/web2py/applications/$1/static/$2
``

Similarly, in Nginx change this:
``
location ~* /(\w+)/static/ {
    root /home/www-data/web2py/applications/;
    expires max;
}
``
into this:
``
location ~* /(\w+)/static(?:/_[\d]+\.[\d]+\.[\d]+)?/(.*)$ {
   alias /home/www-data/web2py/applications/$1/static/$2;
   expires max;
}
``

### Running tasks in the background

In web2py, every HTTP request is served in its own thread. Threads are recycled for efficiency and managed by the web server. For security, the web server sets a time-out on each request. This means that actions should not run tasks that take too long, should not create new threads, and should not fork processes (it is possible but not recommended).

The proper way to run time-consuming tasks is doing it in the background. There is not a single way of doing it, but here we describe three mechanisms that are built into web2py: **cron**, **homemade task queues**, and **scheduler**.

By **cron** we refer to a web2py functionality not to the Unix Cron mechanism. The web2py cron works on windows too.

web2py cron is the way to go if you need tasks in the background at scheduled times and these tasks take a relatively short time compared to the time interval between two calls. Each task runs in its own process, and multiple tasks can run concurrently, but you have no control over how many tasks run. If accidentally one task overlaps with itself, it can cause a database lock and a spike in memory usage.

web2py scheduler takes a different approach. The number of running processes is fixed, and they can run on different machines. Each process is called a worker. Each worker picks a task when available and executes it as soon as possible after the time when it is scheduled to run, but not necessarily at that exact time. There cannot be more processes running than the number of scheduled tasks and therefore no memory spikes. Scheduler tasks can be defined in models and are stored in the database. The web2py scheduler does not implement a distributed queue since it assumes that the time to distribute tasks is negligible compared with the time to run the tasks. Workers pick up the task from the database.

Homemade tasks queues can be a simpler alternative to the web2py scheduler in some cases.

#### Cron
``cron``:inxx

The web2py cron provides the ability for applications to execute tasks at preset times, in a platform-independent manner.

For each application, cron functionality is defined by a crontab file:

``
app/cron/crontab
``

It follows the syntax defined in ref. ``cron``:cite (with some extensions that are specific to web2py).

------
Before web2py 2.1.1, cron was enabled by default and could be disabled with the ``-N`` command line option. Since 2.1.1, cron is disabled by default and can be enabled by the ``-Y`` option. This change was motivated by the desire to push users toward using the new scheduler (which is superior to the cron mechanism) and also because cron may impact on performance.
------

This means that every application can have a separate cron configuration and that cron config can be changed from within web2py without affecting the host OS itself.

Here is an example:
``
0-59/1  *  *  *  *  root python /path/to/python/script.py
30      3  *  *  *  root *applications/admin/cron/db_vacuum.py
*/30    *  *  *  *  root **applications/admin/cron/something.py
@reboot root    *mycontroller/myfunction
@hourly root    *applications/admin/cron/expire_sessions.py
``:code

The last two lines in this example use extensions to regular cron syntax to provide additional web2py functionality.

-------
The file "applications/admin/cron/expire_sessions.py" actually exists and ships with the **admin** app. It checks for expired sessions and deletes them. "applications/admin/cron/crontab" runs this task hourly.
-------

If the task/script is prefixed with an asterisk (``*``) and ends with ``.py``, it will be executed in the web2py environment. This means you will have all the controllers and models at your disposal. If you use two asterisks (``**``), the models will not be executed. This is the recommended way of calling, as it has less overhead and avoids potential locking problems.

Notice that scripts/functions executed in the web2py environment require a manual ``db.commit()`` at the end of the function or the transaction will be reverted.

web2py does not generate tickets or meaningful tracebacks in shell mode, which is how cron is run, so make sure that your web2py code runs without errors before you set it up as a cron task as you will likely not be able to see those errors when run from cron. Moreover, be careful how you use models: while the execution happens in a separate process, database locks have to be taken into account in order to avoid pages waiting for cron tasks that may be blocking the database. Use the ``**`` syntax if you don't need to use the database in your cron task.

You can also call a controller function, in which case there is no need to specify a path. The controller and function will be that of the invoking application. Take special care about the caveats listed above. Example:
``
*/30  *  *  *  *  root *mycontroller/myfunction
``:code

If you specify ``@reboot`` in the first field in the crontab file, the given task will be executed only once, at web2py startup. You can use this feature if you want to pre-cache, check, or initialize data for an application on web2py startup. Note that cron tasks are executed in parallel with the application --- if the application is not ready to serve requests until the cron task is finished, you should implement checks to reflect this. Example:
``
@reboot  root *mycontroller/myfunction
``:code

Depending on how you are invoking web2py, there are four modes of operation for web2py cron.
- ''soft cron'': available under all execution modes
- ''hard cron'': available if using the built-in web server (either directly or via Apache mod_proxy)
- ''external cron'': available if you have access to the system's own cron service
- No cron

The default is hard cron if you are using the built-in web server; in all other cases, the default is soft cron.  Soft cron is the default method if you are using CGI, FASTCGI or WSGI (but note that soft cron is not ``enabled`` by default in the standard ``wsgihandler.py`` file provided with web2py).

Your tasks will be executed on the first call (page load) to web2py after the time specified in crontab; but only after processing the page, so no delay will be observed by the user. Obviously, there is some uncertainty regarding precisely when the task will be executed, depending on the traffic the site receives. Also, the cron task may get interrupted if the web server has a page load timeout set. If these limitations are not acceptable, see ''external cron''. Soft cron is a reasonable last resort, but if your web server allows other cron methods, they should be preferred over soft cron.

Hard cron is the default if you are using the built-in web server (either directly or via Apache mod_proxy). Hard cron is executed in a parallel thread, so unlike soft cron, there are no limitations with regard to run time or execution time precision.

External cron is not default in any scenario, but requires you to have access to the system cron facilities. It runs in a parallel process, so none of the limitations of soft cron apply. This is the recommended way of using cron under WSGI or FASTCGI.

Example of line to add to the system crontab, (usually /etc/crontab):
``
0-59/1 * * * * web2py cd /var/www/web2py/ && python web2py.py -J -C -D 1 >> /tmp/cron.output 2>&1
``:code

With external ``cron``, make sure to add either ``-J`` (or ``--cronjob``, which is the same) as indicated above so that web2py knows that task is executed by cron. Web2py sets this internally with soft and hard ``cron``.

#### Homemade task queues

While cron is useful to run tasks at regular time intervals, it is not always the best solution to run a background task. For this purpose web2py provides the ability to run any python script as if it were inside a controller:
``
python web2py.py -S app -M -R applications/app/private/myscript.py -A a b c
``:code

where ``-S app`` tells web2py to run "myscript.py" as "app", ``-M`` tells web2py to execute models, and ``-A a b c`` passes optional command line arguments ``sys.argv=['applications/app/private/myscript.py','a','b','c']`` to "myscript.py".

This type of background process should not be executed via cron (except perhaps for cron @reboot) because you need to be sure that no more than one instance is running at the same time. With cron it is possible that a process starts at cron iteration 1 and is not completed by cron iteration 2, so cron starts it again, and again, and again - thus jamming the mail server.

In chapter 8, we will provide an example of how to use the above method to send emails.


[[scheduler]]
### web2py Scheduler

The mainstream web2py solution for running tasks in the background (and therefore away from the webserver process) is the built-in scheduler.

The stable API consists of these functions:
- disable()
- resume()
- terminate()
- kill()
- queue_task(),
- task_status()
- stop_task()

The web2py scheduler works very much like the task queue described in the previous sub-section with some differences:
- It provides a standard mechanism for creating, scheduling, and monitoring tasks.
- There is not a single background process but a set of workers processes.
- The job of worker nodes can be monitored because their state, as well as the state of the tasks, is stored in the database.
- It works without web2py but that is not documented here.

The scheduler does not use cron, although one can use cron @reboot to start the worker nodes.

More information about deploying the scheduler under Linux and Windows is in the Deployment recipes chapter.

In the scheduler, a task is simply a function defined in a model (or in a module and imported by a model). For example:

``
def task_add(a, b):
    return a + b
``:code

Tasks will always be called in the same environment seen by controllers and therefore they see all the global variables defined in models, including database connections (``db``).
Tasks differ from a controller action because they are not associated with an HTTP request and therefore there is no ``request.env``.
Also, tasks can access another environmental variable that is not present in normal requests: ``W2P_TASK``. ``W2P_TASK.id`` holds the ``scheduler_task.id`` and ``W2P_TASK.uuid`` the ``scheduler_task.uuid`` field of the task that is running.

------
Remember to call ``db.commit()`` at the end of every task if it involves inserts/updates to the database. web2py commits by default at the end of a successful action but the scheduler tasks are not actions.
------

To enable the scheduler you must instantiate the Scheduler class in a model.
The recommended way to enable the scheduler to your app is to create a model file named ``scheduler.py`` and define your function there. After the functions, you can put the following code into the model:

``
from gluon.scheduler import Scheduler
scheduler = Scheduler(db)
``:code

If your tasks are defined in a module (as opposed to a model) you may have to restart the workers.

The task is scheduled with

``
scheduler.queue_task(task_add, pvars=dict(a=1, b=2))
``:code


#### Parameters

The first argument of the ``Scheduler`` class must be the database to be used by the scheduler to communicate with the workers. This can be the ``db`` of the app or another dedicated ``db``, perhaps one shared by multiple apps. If you use SQLite it's recommended to use a separate db from the one used by your app in order to keep the app responsive.
Once the tasks are defined and the ``Scheduler`` is instantiated, all that is needed to do is to start the workers. You can do that in several ways:

``
python web2py.py -K myapp
``
starts a worker for the app ``myapp``. If you want start multiple workers for the same app, you can do so just passing ``myapp,myapp``. You can pass also the ``group_names`` (overriding the one set in your model) with

``
python web2py.py -K myapp:group1:group2,myotherapp:group1
``

If you have a model called ``scheduler.py`` you can start/stop the workers from web2py's default window (the one you use to set the ip address and the port).

#### Scheduler Deployment
One last nice addition: if you use the embedded webserver, you can start the webserver and the scheduler with just one line of code (this assumes you don't want the web2py window popping up, else you can use the "Schedulers" menu instead)

``
python web2py.py -a yourpass -K myapp -X
``
You can pass the usual parameters (-i, -p, here -a prevents the window from showing up), pass whatever app in the -K parameter and append a -X. The scheduler will run alongside the webserver!

Windows users looking to create a service should see the Deployment Recipes chapter.


[[scheduler_signature]]
#### Complete Scheduler signature
Scheduler's complete signature is:

``
Scheduler(db,
          tasks=None,
          migrate=True,
          worker_name=None,
          group_names=None,
          heartbeat=HEARTBEAT,
          max_empty_runs=0,
          discard_results=False,
          utc_time=False)
``:code

Let's see them in order:

- ``db`` is the database DAL instance where you want the scheduler tables be placed.
- ``tasks`` is a dictionary that maps task names into functions. If you do not pass this parameter, function will be searched in the app environment.
- ``worker_name`` is None by default. As soon as the worker is started, a worker name is generated as hostname-uuid. If you want to specify that, be sure that it's unique.
- ``group_names`` is by default set to **[main]**. All tasks have a ``group_name`` parameter, set to **main** by default. Workers can only pick up tasks of their assigned group.

------
NB: This is useful if you have different workers instances (e.g. on different machines) and you want to assign tasks to a specific worker.

NB2: It's possible to assign a worker more groups, and they can be also all the same, as ``['mygroup','mygroup']``. Tasks will be distributed taking into consideration that a worker with group_names ``['mygroup','mygroup']`` is able to process the double of the tasks a worker with group_names ``['mygroup']`` is.
------

- ``heartbeat`` is by default set to 3 seconds. This parameter is the one controlling how often a scheduler will check its status on the ``scheduler_worker`` table and see if there are any **ASSIGNED** tasks to itself to process.
- ``max_empty_runs`` is 0 by default, that means that the worker will continue to process tasks as soon as they are **ASSIGNED**. If you set this to a value of, let's say, 10, a worker will die automatically if it's **ACTIVE** and no tasks are **ASSIGNED** to it for 10 loops. A loop is when a worker searches for tasks, every 3 seconds (or the set ``heartbeat``)
- ``discard_results`` is False by default. If set to True, no scheduler_run records will be created.

------
NB: scheduler_run records will be created as before for **FAILED**, **TIMEOUT** and **STOPPED** tasks's statuses.
------

- ``utc_time`` is False by default. If you need to coordinate with workers living in different timezones, or don't have problems with solar/DST times, supplying datetimes from different countries, etc, you can set this to True. The scheduler will honor the UTC time and work leaving the local time aside. Caveat: you need to schedule tasks with UTC times (for start_time, stop_time, and so on.)

Now we have the infrastructure in place: defined the tasks, told the scheduler about them, started the worker(s). What remains is to actually schedule the tasks


#### Tasks
Tasks can be scheduled programmatically or via appadmin. In fact, a task is scheduled simply by adding an entry in the table "scheduler_task", which you can access via appadmin:

``
http://127.0.0.1:8000/myapp/appadmin/insert/db/scheduler_task
``

The meaning of the fields in this table is obvious. The "args" and "vars"" fields are the values to be passed to the task in JSON format. In the case of the "task_add" above, an example of "args" and "vars" could be:

``
args = [3, 4]
vars = {}
``:code

or

``
args = []
vars = {'a': 3, 'b': 4}
``:code

The ``scheduler_task`` table is the one where tasks are organized.

To add tasks via the API, use
``
scheduler.queue_task('mytask', ...)
``
which is documented [[below #queue_task_sig]] .


#### Task Lifecycle
All tasks follow a lifecycle


[[scheduler tasks @///image/ce8edcc3.png center]]

By default, when you send a task to the scheduler,
it is in the **QUEUED** status.
If you need it to be executed later, use the ``start_time`` parameter (default = now).
If for some reason you need to be sure that the task does not
get executed after a certain point in time (maybe a request to a web service
that shuts down at 1AM, a mail that needs to be sent not after the working hours, etc...) you can set a ``stop_time`` (default = None) for it.
If your task is NOT picked up by a worker before ``stop_time``, it will be set as **EXPIRED**.
Tasks with no ``stop_time`` set or picked up **BEFORE** stop_time are **ASSIGNED** to a worker. When a workers picks up a task, its status is set to **RUNNING**.

**RUNNING** tasks may end up:
- **TIMEOUT** when more than ``n`` seconds passed with ``timeout`` parameter (default = 60 seconds).
- **FAILED** when an exception is detected,
- **COMPLETED** when they successfully complete.

Values for ``start_time`` and ``stop_time`` should be datetime objects. To schedule "mytask" to run at 30 seconds from the current time, for example, you would do the following:

``
from datetime import timedelta as timed
scheduler.queue_task('mytask', start_time=request.now + timed(seconds=30))
``:code

Additionally, you can control how many times a task should be repeated (i.e. you need to aggregate some data at specified intervals). To do so, set the ``repeats``
parameter (default = 1 time only, 0 = unlimited). You can influence how many seconds should pass between executions with the ``period`` parameter (default = 60 seconds).

------
Default behavior: The time period is not calculated between the END of the first round and the START of the next, but from the START time of the first round to the START time of the next cycle).
This can cause accumulating 'drift' in the start time of a job.
After v 2.8.2, a new parameter ``prevent_drift`` was added, defaulting to False. If set to True when queing a task, the start_time parameter will take precedence over the period, preventing drift.
------

You can also set how many times the function can raise an exception (i.e. requesting data from a slow web service) and be queued again instead of stopping in **FAILED**  status using the parameter ``retry_failed`` (default = 0, -1 = unlimited).

[[task repeats @///image/7d8b85e4.png center]]

Summary: you have
- ``period`` and ``repeats`` to get an automatically rescheduled function
- ``timeout`` to be sure that a function doesn't exceed a certain amount of time
- ``retry_failed`` to control how many times the task can "fail"
- ``start_time`` and ``stop_time`` to schedule a function in a restricted timeframe

#### ``queue_task`` [[queue_task_sig]]

The method:
``
scheduler.queue_task(function,
                     pargs=[],
                     pvars={},
                     start_time=now,  # datetime
                     stop_time=None,  # datetime
                     timeout = 60,  # seconds
                     prevent_drift=False,
                     period=60,  # seconds
                     immediate=False,
                     repeats=1)
``:code
allows you to queue tasks to be executed by workers.
It returns a row (see [[here #queue_task_return]]), and it takes the following parameters:

- ``function`` (required): It can be a task name or a reference to an actual function.
- ``pargs``: are the arguments to be passed to the task, stored as a Python list.
- ``pvars`` : are the named arguments to be passed to the task, stored as a Python dictionary.
- all other scheduler_task columns can be passed as keyword arguments; the most important are shown.

For example:

``
scheduler.queue_task('demo1', [1, 2])
``

does the exact same thing as

``
scheduler.queue_task('demo1', pvars={'a': 1, 'b': 2})
``:code

as

``
st.validate_and_insert(function_name='demo1', args=json.dumps([1, 2]))
``:code

and as:

``
st.validate_and_insert(function_name='demo1', vars=json.dumps({'a': 1, 'b': 2}))
``:code

Here is a more complex complete example:
``
def task_add(a, b):
    return a + b

scheduler = Scheduler(db, tasks=dict(demo1=task_add))

scheduler.queue_task('demo1', pvars=dict(a=1, b=2), repeats = 0, period=180)
``:code

Since version 2.4.1 if you pass an additional parameter ``immediate=True`` it will force the main worker to reassign tasks. Until 2.4.1, the worker checks for new tasks every 5 cycles (so, ``5*heartbeats`` seconds). If you had an app that needed to check frequently for new tasks, to get a ''snappy'' behaviour you were forced to lower the ``heartbeat`` parameter, putting the db under pressure for no reason. With ``immediate=True`` you can force the check for new tasks: it will happen at most as ``heartbeat`` seconds are passed

A call to ``scheduler.queue_task`` returns the task ``id`` and ``uuid`` of the task you queued (can be the one you passed or the auto-generated one), and possible ``errors``: [[queue_task_return]]

``
<Row {'errors': {}, 'id': 1, 'uuid': '08e6433a-cf07-4cea-a4cb-01f16ae5f414'}>
``

If there are errors (usually syntax error or input validation errors),
you get the result of the validation, and id and uuid will be None

``
<Row {'errors': {'period': 'enter an integer greater than or equal to 0'}, 'id': None, 'uuid': None}>
``

#### ``task_status`` [[task_status]]

To query the scheduler about tasks, use ``task_status``
``
scheduler.task_status(ref, output=False)
``:code

The argument ``ref`` can be
- integer --> lookup will be done by scheduler_task.id
- string --> lookup will be done by scheduler_task.uuid
- query --> lookup as you wish (as in db.scheduler_task.task_name == 'test1')
``output=True`` fetches the scheduler_run record

It returns a single Row object, for the most recent queued task matching the criteria.

scheduler_run record is fetched by a left join, so it can
have all fields == None

##### Example: retrieving scheduler task status, results and tracebacks
Here the scheduler instance is ``mysched``

``
task = mysched.queue_task(f, ...)
task_status = mysched.task_status(task.id, output=True)
traceback = task_status.scheduler_run.traceback
result = task_status.scheduler_run.run_result #or
result = task_status.result
``:code

#### Results and output

The table "scheduler_run" stores the status of all running tasks. Each record references a task that has been picked up by a worker.  One task can have multiple runs. For example, a task scheduled to repeat 10 times an hour will probably have 10 runs (unless one fails or they take longer than 1 hour). Beware that if the task has no return values, it is removed from the scheduler_run table as soon as it is finished.

Possible run statuses are:

``
RUNNING, COMPLETED, FAILED, TIMEOUT
``

If the run is completed, no exceptions are thrown, and there is no task timeout, the run is marked as ``COMPLETED`` and the task is marked as ``QUEUED`` or ``COMPLETED`` depending on whether it is supposed to run again at a later time. The output of the task is serialized in JSON and stored in the run record.

When a ``RUNNING`` task throws an exception, the run is mark as ``FAILED`` and the task is marked as ``FAILED``. The traceback is stored in the run record.

Similarly, when a run exceeds the timeout, it is stopped and marked as ``TIMEOUT``, and the task is marked as ``TIMEOUT``.

In any case, the stdout is captured and also logged into the run record.

------
Due to multiprocessing limitations, beware of using either huge return values or huge print statements on the queued functions.
As the output is buffered, your task may fail just because the parent process hangs on reading values.
Also, leave print statements to the minimum, and if in need use a proper logging library that doesn't clutter stdout.
As for huge return values, a better option can be to use a table where the function saves the result: you can return
only the reference to the specific line of results without hindering the master process of the scheduler.
------

Using appadmin, one can check all ``RUNNING`` tasks, the output of ``COMPLETED`` tasks, the error of ``FAILED`` tasks, etc.

The scheduler also creates one more table called "scheduler_worker", which stores the workers' heartbeat and their status.

#### Managing processes

Worker fine management is hard. This module tries not to leave behind any platform (Mac, Win, Linux) .

When you start a worker, you may later want to:
- kill it "no matter what it's doing"
- kill it only if it is not processing tasks
- put it to sleep
Maybe you have yet some tasks queued, and you want to save some resources.
You know you want them processed every hour, so, you'll want to:
- process all queued tasks and die automatically
All of these things are possible managing ``Scheduler`` parameters or the ``scheduler_worker`` table.
To be more precise, for started workers you can change the ``status`` value of any worker to influence
its behavior.
As for tasks, workers can be in one of the following statuses: ACTIVE, DISABLED, TERMINATE or KILLED.

**ACTIVE** and **DISABLED** are "persistent", while **TERMINATE** or **KILL**, as statuses
name suggest, are more "commands" than real statuses.
Hitting ctrl+c is equal to set a worker to **KILL**

[[workers statuses @///image/bd891eed.png center]]

There are a few commodity functions since version 2.4.1 (self-explanatory)
``
scheduler.disable()
scheduler.resume()
scheduler.terminate()
scheduler.kill()
``:code

each function take an optional parameter, that can be a string or a list, to manage workers based on their ``group_names``. It defaults to the ``group_names`` defined in the scheduler istantiation.

An example is better than a thousand words: ``scheduler.terminate('high_prio')`` will TERMINATE all the workers that are processing the ``high_prio`` tasks, while ``scheduler.terminate(['high_prio', 'low_prio'])`` will terminate all ``high_prio`` and ``low_prio`` workers.
------
Watch out: if you have a worker processing ``high_prio`` and ``low_prio``, ``scheduler.terminate('high_prio')`` will terminate the worker alltogether, even if you didn't want to terminate ``low_prio`` too.
------

Everything that one can do via appadmin one can do programmatically by inserting and updating records in these tables.

Anyway, one should not update records relative to ``RUNNING`` tasks as this may create an un-expected behavior. The best practice is to queue tasks using the "queue_task" method.

For example:

``
scheduler.queue_task(function_name='task_add',
                     pargs=[],
                     pvars={'a': 3, 'b': 4},
                     repeats=10,  # run 10 times
                     period=3600,  # every 1h
                     timeout=120,  # should take less than 120 seconds
                     )
``:code

Notice that fields "times_run", "last_run_time" and "assigned_worker_name" are not provided at schedule time but are filled automatically by the workers.

You can also retrieve the output of completed tasks:

``
completed_runs = db(db.scheduler_run.run_status='COMPLETED').select()
``:code

------
The scheduler is considered experimental because it needs more extensive testing and because the table structure may change as more features are added.
------

#### Reporting progress percentages

A special "word" encountered in the print statements of your functions clear all
the previous output. That word is ``!clear!``.
This, coupled with the ``sync_output`` parameter, allows to report percentages.


Here is an example:

``
def reporting_percentages():
    time.sleep(5)
    print '50%'
    time.sleep(5)
    print '!clear!100%'
    return 1
``

The function ``reporting_percentages`` sleeps for 5 seconds, outputs ``50%``.
Then, it sleeps other 5 seconds and outputs ``100%``. Note that the output in the scheduler_run table is synced every 2 seconds and that the second print statement that contains ``!clear!100%`` gets the ``50%`` output cleared and replaced by ``100%`` only.

``
scheduler.queue_task(reporting_percentages, sync_output=2)
``:code


[[modules]]
### Third party modules
``import``:inxx

web2py is written in Python, so it can import and use any Python module, including third party modules. It just needs to be able to find them. As with any Python application, modules can be installed in the official Python "site-packages" directory, and they can then be imported from anywhere inside your code.

Modules in the "site-packages" directory are, as the name suggests, site-level packages. Applications requiring site-packages are not portable unless these modules are installed separately. The advantage of having modules in "site-packages" is that multiple applications can share them. Let's consider, for example, the plotting package called "matplotlib". You can install it from the shell using the PEAK ``easy_install`` command ``easy-install``:cite (or its modern replacement ``pip`` ``PIP``:cite ):
``
easy_install py-matplotlib
``:code

and then you can import it into any model/controller/view with:
``
import matplotlib
``:code

The web2py source distribution, and the Windows binary distribution has a site-packages in the top-level folder. The Mac binary distribution has a site-packages folder in the folder:

``web2py.app/Contents/Resources/site-packages``:code

The problem with using site-packages is that it becomes difficult to use different versions of a single module at the same time, for example there could be two applications but each one uses a different version of the same file.  In this example, ``sys.path`` cannot be altered because it would affect both applications.

For this kind of situation, web2py provides another way to import modules in such a way that the global ``sys.path`` is not altered: by placing them in the "modules" folder of an application. One side benefit is that the module will be automatically copied and distributed with the application.

------
Once a module "mymodule.py" is placed into an app "modules/" folder, it can be imported from anywhere inside a web2py application (without need to alter ``sys.path`` with):
``
import mymodule
``
------

### Execution environment
``exec_environment``:inxx

-----
While everything discussed here works fine, we recommend instead building your application using components, as described in chapter 12.
-----

web2py model and controller files are not Python modules in that they cannot be imported using the Python ``import`` statement. The reason for this is that models and controllers are designed to be executed in a prepared environment that has been pre-populated with web2py global objects (request, response, session, cache and T) and helper functions. This is necessary because Python is a statically (lexically) scoped language, whereas the web2py environment is created dynamically.

web2py provides the ``exec_environment`` function to allow you to access models and controllers directly. ``exec_environment`` creates a web2py execution environment, loads the file into it and then returns a Storage object containing the environment. The Storage object also serves as a namespace mechanism. Any Python file designed to be executed in the execution environment can be loaded using ``exec_environment``. Uses for ``exec_environment`` include:
- Accessing data (models) from other applications.
- Accessing global objects from other models or controllers.
- Executing controller functions from other controllers.
- Loading site-wide helper libraries.

This example reads rows from the ``user`` table in the ``cas`` application:
``
from gluon.shell import exec_environment
cas = exec_environment('applications/cas/models/db.py')
rows = cas.db().select(cas.db.user.ALL)
``:code

Another example: suppose you have a controller "other.py" that contains:
``
def some_action():
    return dict(remote_addr=request.env.remote_addr)
``:code

Here is how you can call this action from another controller (or from the web2py shell):
``
from gluon.shell import exec_environment
other = exec_environment('applications/app/controllers/other.py', request=request)
result = other.some_action()
``:code

In line 2, ``request=request`` is optional. It has the effect of passing the current request to the environment of "other". Without this argument, the environment would contain a new and empty (apart from ``request.folder``) request object. It is also possible to pass a response and a session object to ``exec_environment``. Be careful when passing request, response and session objects --- modification by the called action or coding dependencies in the called action could lead to unexpected side effects.

The function call in line 3 does not execute the view; it simply returns the dictionary unless ``response.render`` is called explicitly by "some_action".

One final caution: don't use ``exec_environment`` inappropriately. If you want the results of actions in another application, you probably should implement an XML-RPC API (implementing an XML-RPC API with web2py is almost trivial). Don't use ``exec_environment`` as a redirection mechanism; use the ``redirect`` helper.

### Cooperation
``cooperation``:inxx

There are many ways applications can cooperate:
- Applications can connect to the same database and thus share tables. It is not necessary that all tables in the database are defined by all applications, but they must be defined by those applications that use them. All applications that use the same table, but one, must define the table with ``migrate=False``.
- Applications can embed components from other applications using the LOAD helper (described in Chapter 12).
- Applications can share sessions.
- Applications can call each other's actions remotely via XML-RPC.
- Applications can access each other's files via the filesystem (assuming they share the same filesystem).
- Applications can call each other's actions locally using ``exec_environment`` as discussed above.
- Applications can import each other's modules using the syntax:
``
from applications.otherapp.modules import mymodule
``:code

or

``
import applications.otherapp.modules.othermodule
``:code

- Applications can import any module in the ``PYTHONPATH`` search path, ``sys.path``.

One app can load the session of another app using the command:

``
session.connect(request, response, masterapp='appname', db=db)
``:code

Here "appname" is the name of the master application, the one that sets the initial session_id in the cookie. ``db`` is a database connection to the database that contains the session table (``web2py_session``). All apps that share sessions must use the same database for session storage.


### Logging

Python provides logging APIs. Web2py provides a mechanism to configure it so
that apps can use it.

In your application, you can create a logger, for example in a model:

``
import logging
logger = logging.getLogger("web2py.app.myapp")
logger.setLevel(logging.DEBUG)
``:code

and you can use it to log messages of various importance

``
logger.debug("Just checking that %s" % details)
logger.info("You ought to know that %s" % details)
logger.warn("Mind that %s" % details)
logger.error("Oops, something bad happened %s" % details)
``:code

``logging`` is a standard python module described here:
``
http://docs.python.org/library/logging.html
``
The string "web2py.app.myapp" defines an app-level logger.

For this to work properly, you need a configuration file for the logger.
One is provided by web2py in the "examples" folder "logging.example.conf". You need to copy the file to web2py's directory and rename the file to "logging.conf" and customize it as necessary.

This file is self documenting, so you should open it and read it.

To create a configurable logger for application "myapp", you must add myapp to
the [loggers] keys list:

``
[loggers]
keys=root,rocket,markdown,web2py,rewrite,app,welcome,myapp
``:code

and you must add a [logger_myapp] section, using [logger_welcome] as a starting point.

``
[logger_myapp]
level=WARNING
qualname=web2py.app.myapp
handlers=consoleHandler
propagate=0
``:code

The "handlers" directive specifies the type of logging and here it is logging "myapp" to the console.

### WSGI
``WSGI``:inxx

web2py and WSGI have a love-hate relationship. Our perspective is that WSGI was developed as a protocol to connect web servers to web applications in a portable way, and we use it for that purpose. web2py at its core is a WSGI application: ``gluon.main.wsgibase``. Some developers have pushed WSGI to its limits as a protocol for middleware communications and develop web applications as an onion with many layers (each layer being a WSGI middleware developed independently of the entire framework). web2py does not adopt this structure internally. This is because we feel the core functionality of a frameworks (handling cookies, session, errors, transactions, dispatching) can be better optimized for speed and security if they are handled by a single comprehensive layer.

Yet web2py allows you to use third party WSGI applications and middleware in three ways (and their combinations):
- You can edit the file "wsgihandler.py" and include any third party WSGI middleware.
- You can connect third party WSGI middleware to any specific action in your apps.
- You can call a third party WSGI app from your actions.

The only limitation is that you cannot use third party middleware to replace core web2py functions.

#### External middleware

Consider the file "wsgibase.py":
``
#...
LOGGING = False
#...
if LOGGING:
    application = gluon.main.appfactory(wsgiapp=gluon.main.wsgibase,
                                        logfilename='httpserver.log',
                                        profilerfilename=None)
else:
    application = gluon.main.wsgibase
``:code

When ``LOGGING`` is set to ``True``, ``gluon.main.wsgibase`` is wrapped by the middleware function ``gluon.main.appfactory``. It provides logging to the "httpserver.log" file. In a similar fashion you can add any third party middleware. We refer to the official WSGI documentation for more details.

#### Internal middleware

Given any action in your controllers (for example ``index``) and any third party middleware application (for example ``MyMiddleware``, which converts output to upper case), you can use a web2py decorator to apply the middleware to that action. Here is an example:
``
class MyMiddleware:
    """converts output to upper case"""
    def __init__(self, app):
        self.app = app
    def __call__(self, environ, start_response):
        items = self.app(environ, start_response)
        return [item.upper() for item in items]

@request.wsgi.middleware(MyMiddleware)
def index():
    return 'hello world'
``:code

We cannot promise that all third party middleware will work with this mechanism.

#### Calling ''WSGI'' applications

It is easy to call WSGI app from a web2py action. Here is an example:
``
def test_wsgi_app(environ, start_response):
    """this is a test WSGI app"""
    status = '200 OK'
    response_headers = [('Content-type', 'text/plain'),
                        ('Content-Length', '13')]
    start_response(status, response_headers)
    return ['hello world!\n']

def index():
    """a test action that calls the previous app and escapes output"""
    items = test_wsgi_app(request.wsgi.environ,
                          request.wsgi.start_response)
    for item in items:
        response.write(item, escape=False)
    return response.body.getvalue()
``:code

In this case, the ``index`` action calls ``test_wsgi_app`` and escapes the returned value before returning it. Notice that ``index`` is not itself a WSGI app and it must use the normal web2py API (such as ``response.write`` to write to the socket).
